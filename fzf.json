[
  {
    "id": 60493314,
    "timestamp": "2026-02-23T11:43:15.003Z",
    "title": "fzf: Installation | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/installation/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nInstallation #\nUsing Homebrew #\n\nHomebrew is the recommended way to install fzf, as it provides the most recent version of fzf.\n\nbrew install fzf\n\nUsing other package managers #\nLinux #\nClick to expand\nWindows #\nClick to expand\nGetting the latest binary #\n\nWhile fzf is available on all major package managers, they may provide an old version of fzf. If that‚Äôs the case, you can download the latest binary from the releases page and put it in your $PATH.\n\nSetting up shell integration #\n\nfzf comes with shell integration scripts that set up useful key bindings and fuzzy completion so that fzf is still useful even if you‚Äôre not well versed in shell scripting.\n\nbash (~/.bashrc)\neval \"$(fzf --bash)\"\n\nzsh (~/.zshrc)\nsource <(fzf --zsh)\n\nfish (~/.config/fish/config.fish)\nfzf --fish | source\n\nLast modified: Jun 2, 2024\nCopyright ¬© 2025 Junegunn Choi\nUsing Homebrew\nUsing other package managers\nLinux\nWindows\nGetting the latest binary\nSetting up shell integration"
  },
  {
    "id": 60493315,
    "timestamp": "2026-02-23T11:43:15.004Z",
    "title": "fzf: Getting Started | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/getting-started/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nGetting Started #\nUnderstanding fzf #\n\nBasically, you can think of fzf as an interactive version of ‚Äúgrep‚Äù (with bells and whistles, lots of bells and whistles).\n\nYou feed lines of text to fzf via standard input,\nfzf starts an interactive terminal interface where you can narrow down the list using fuzzy matching algorithm.\nAnd when you finally make a selection, fzf prints it out to standard output.\nI\nn\np\nu\nt\nl\ni\nn\ne\ns\nS\nT\nD\nI\nN\nf\nz\nüëÄ\nf\nS\nT\nD\nO\nU\nT\nO\nu\nt\np\nu\nt\nl\ni\nn\ne\n(\ns\n)\n\nWhat I‚Äôm trying to say here is that fzf is essentially a text filter; it‚Äôs up to you to provide the input list, and it‚Äôs up to you to do something with the filtered output.\n\nThis may not sound very exciting, but this simple, generic mechanism is what makes fzf really versatile, because you can compose it with any other command-line tool that generates or consumes text lines.\n\nls | fzf | wc\n\nfind * | fzf | md5sum\n\ngit ls-files | fzf | xargs git log\n\nps -ef | sed 1d | fzf | awk '{print $2}' | xargs kill\n\n\nAnd unlike grep:\n\nfzf is interactive. You can change the query and see the result in real-time. And it‚Äôs really fast.\nfzf performs ‚Äúfuzzy‚Äù matching by default. Your query doesn‚Äôt have to be exact. For example, you can type fzf to match ‚Äúfuzzy finder‚Äù. So you can be really quick (and sloppy) and still get the result you want.\nfzf also allows you to ‚Äúpreview‚Äù the item in real-time. You don‚Äôt have to manually run cat FILE or git show BRANCH commands to really see which one is the right one.\nfzf is fully customizable through its event-action binding mechanism. It is so versatile that many even see it as a framework for building interactive terminal applications.\nAn example #\nInteractive git branch selector #\n\nSo here‚Äôs one real-world example. Take a look.\n\ngit branch | fzf | cut -c 3- | xargs git checkout\n\nList of branches is given to fzf\nYou select a branch with fzf\ncut command strips off the leading characters before the branch name (e.g. * master)\nxargs runs git checkout with the selected branch name\n\nCongratulations! üéâ You just implemented a fully-working interactive git branch selector in a single line of code. You probably don‚Äôt want to type the whole command every time, so let‚Äôs create an alias.\n\nalias gcb='git branch | fzf | cut -c 3- | xargs git checkout'\n\nReal-time preview of the content #\n\nAs mentioned above, you can ‚Äúpreview‚Äù the content of the branch using ‚Äúpreview‚Äù option.\n\ngit branch | fzf --preview 'git show --color=always {-1}' |\n\n             cut -c 3- | xargs git checkout\n\n{-1} means the last token. This is to ignore leading * characters from git branch output. (e.g. Take master from * master, or devel from ‚Äá‚Äádevel)\ngit show command suppresses colored output when the output is not a terminal, so we explicitly set --color=always\nMaking it even better #\n\nBuilding a new command with the selected item and running it is such a common pattern, fzf provides a shorthand method to turn itself into a different process.\n\ngit branch | fzf --preview 'git show --color=always {-1}' \\\n\n                 --bind 'enter:become(git checkout {-1})'\n\nThis uses fzf‚Äôs event-action binding mechanism (--bind). In this case, we bind enter key event to become action.\nSo when you press ‚Äúenter‚Äù key, fzf ‚Äúbecome\"s git checkout THE_BRANCH command.\n\nSo far, you should have noticed that fzf runs in full-screen mode. But that is not always desirable, so fzf implements alternative display modes.\n\ngit branch | fzf --preview 'git show --color=always {-1}' \\\n\n                 --bind 'enter:become(git checkout {-1})' \\\n\n                 --height 40% --layout reverse\n\n\nWith --height, fzf starts below the current cursor position. In this display mode, --layout=reverse, which displays the candidate list from top to bottom, usually looks better.\n\n(If you‚Äôre like me and always on tmux, you can make fzf start in a tmux popup with --tmux option. You can learn more about the options from fzf --man.)\n\nShell Integration #\n\nIf you‚Äôre not ready to get serious with scripting, don‚Äôt worry. fzf comes with ‚Äúready-to-wear‚Äù shell integration scripts that set up useful key bindings and fuzzy completion.\n\nLet‚Äôs move on to Shell Integration.\n\nLast modified: Jun 6, 2024\nCopyright ¬© 2025 Junegunn Choi\nUnderstanding fzf\nAn example\nInteractive git branch selector\nReal-time preview of the content\nMaking it even better\nShell Integration"
  },
  {
    "id": 60493316,
    "timestamp": "2026-02-23T11:43:15.005Z",
    "title": "fzf: Shell Integration | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/shell-integration/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nShell Integration #\n\nTo be useful out of the box without any scripting effort, fzf provides shell integration for bash, zsh and fish.\n\nCTRL-T, ALT-C, CTRL-R for bash, zsh, and fish\nFuzzy completion for bash and zsh\nSetting up shell integration #\n\nTo set up shell integration, add the following to your shell configuration file:\n\nbash (~/.bashrc)\neval \"$(fzf --bash)\"\n\nzsh (~/.zshrc)\nsource <(fzf --zsh)\n\nfish (~/.config/fish/config.fish)\nfzf --fish | source\n\n\nTip\n\nYou can disable CTRL-T or ALT-C binding by setting FZF_CTRL_T_COMMAND or FZF_ALT_C_COMMAND to an empty string when sourcing the script. For example, to disable ALT-C binding:\n\nbash: FZF_ALT_C_COMMAND= eval \"$(fzf --bash)\"\nzsh: FZF_ALT_C_COMMAND= source <(fzf --zsh)\nfish: fzf --fish | FZF_ALT_C_COMMAND= source\n\nSetting the variables after sourcing the script will have no effect.\n\nKey bindings #\nCTRL-R #\n\nPaste the selected command from history onto the command-line\n\nIf you want to see the commands in chronological order, press CTRL-R again which toggles sorting by relevance\nPress CTRL-/ to toggle line wrapping and see the whole command\nSet FZF_CTRL_R_OPTS to pass additional options to fzf\n# CTRL-Y to copy the command into clipboard using pbcopy\n\nexport FZF_CTRL_R_OPTS=\"\n\n  --bind 'ctrl-y:execute-silent(echo -n {2..} | pbcopy)+abort'\n\n  --color header:italic\n\n  --header 'Press CTRL-Y to copy command into clipboard'\"\n\nCTRL-T #\n\nPaste the selected files and directories onto the command-line\n\nThe list is generated using --walker file,dir,follow,hidden option\nYou can override the behavior by setting FZF_CTRL_T_COMMAND to a custom command that generates the desired list\nOr you can set --walker* options in FZF_CTRL_T_OPTS\nSet FZF_CTRL_T_OPTS to pass additional options to fzf\n# Preview file content using bat (https://github.com/sharkdp/bat)\n\nexport FZF_CTRL_T_OPTS=\"\n\n  --walker-skip .git,node_modules,target\n\n  --preview 'bat -n --color=always {}'\n\n  --bind 'ctrl-/:change-preview-window(down|hidden|)'\"\n\nCan be disabled by setting FZF_CTRL_T_COMMAND to an empty string when sourcing the script\nALT-C #\n\ncd into the selected directory\n\nThe list is generated using --walker dir,follow,hidden option\nSet FZF_ALT_C_COMMAND to override the default command\nOr you can set --walker-* options in FZF_ALT_C_OPTS\nSet FZF_ALT_C_OPTS to pass additional options to fzf\n# Print tree structure in the preview window\n\nexport FZF_ALT_C_OPTS=\"\n\n  --walker-skip .git,node_modules,target\n\n  --preview 'tree -C {}'\"\n\nCan be disabled by setting FZF_ALT_C_COMMAND to an empty string when sourcing the script\nKey bindings for Git objects #\n\nfzf-git.sh project provides a bunch of key bindings for completing Git objects. You should definitely check it out.\n\nFuzzy completion for bash and zsh #\nFiles and directories #\n\nFuzzy completion for files and directories can be triggered if the word before the cursor ends with the trigger sequence, which is by default **.\n\nCOMMAND [DIRECTORY/][FUZZY_PATTERN]**<TAB>\n# Files under the current directory\n\n# - You can select multiple items with TAB key\n\nvim **<TAB>\n\n\n\n# Files under parent directory\n\nvim ../**<TAB>\n\n\n\n# Files under parent directory that match `fzf`\n\nvim ../fzf**<TAB>\n\n\n\n# Files under your home directory\n\nvim ~/**<TAB>\n\n\n\n\n\n# Directories under current directory (single-selection)\n\ncd **<TAB>\n\n\n\n# Directories under ~/github that match `fzf`\n\ncd ~/github/fzf**<TAB>\n\nProcess IDs #\n\nFuzzy completion for PIDs is provided for kill command.\n\n# Can select multiple processes with <TAB> or <Shift-TAB> keys\n\nkill -9 **<TAB>\n\nHost names #\n\nFor ssh and telnet commands, fuzzy completion for hostnames is provided. The names are extracted from /etc/hosts and ~/.ssh/config.\n\nssh **<TAB>\n\ntelnet **<TAB>\n\nEnvironment variables / Aliases #\nunset **<TAB>\n\nexport **<TAB>\n\nunalias **<TAB>\n\nLast modified: Jul 8, 2024\nCopyright ¬© 2025 Junegunn Choi\nSetting up shell integration\nKey bindings\nCTRL-R\nCTRL-T\nALT-C\nKey bindings for Git objects\nFuzzy completion for bash and zsh\nFiles and directories\nProcess IDs\nHost names\nEnvironment variables / Aliases"
  },
  {
    "id": 60493318,
    "timestamp": "2026-02-23T11:43:15.017Z",
    "title": "fzf: Browsing log streams | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/tips/browsing-log-streams/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nBrowsing log streams with fzf #\n\nIn order to allow changing queries and getting the updated results in real-time, fzf keeps the whole input list in memory and scans the list whenever the query changes.\n\nSo if you attach fzf to an endless input stream, such as server logs, the memory usage will grow indefinitely and fzf will eventually crash.\n\nTo work around this limitation, fzf provides --tail=NUM option that allows you to limit the number of items to keep in memory. When the number of items exceeds the limit, fzf will drop the oldest items from the list.\n\n# Make sure fzf doesn't blow up\n\ncat /dev/random | xxd | fzf --tail 1000 --tac --wrap\n\nBest practices #\nUse --tac to see the newest items up front\nUse --wrap to prevent truncation of long lines\nYou might want to use --no-sort option to keep the order of the items intact\nWithout sorting, you‚Äôll likely see many irrelevant matches, so try disabling fuzzy matching with --exact\nExamples #\nBrowsing local logs files #\ntail -f *.log | fzf --tail 100000 --tac --no-sort --exact --wrap\n\nBrowsing Kubernetes logs using stern #\nstern . --color always 2>&1 |\n\n    fzf --ansi --tail 100000 --tac --no-sort --exact --wrap \\\n\n        --bind 'ctrl-o:execute:vim -n <(kubectl logs {1})' \\\n\n        --bind 'enter:execute:kubectl exec -it {1} -- bash' \\\n\n        --header '‚ï± Enter (kubectl exec) ‚ï± CTRL-O (open log in vim) ‚ï±'\n\n--color always and --ansi #\n\nstern allows you to see logs from multiple pods at once, each in a different color. But like most other programs, it suppresses color codes when the output is redirected to another program.\n\nTo preserve the colors, use --color always option, and make fzf recognize the ANSI color codes by specifying --ansi option.\n\n--bind #\n\nThe above example uses --bind option to define two custom bindings.\n\nYou can press ctrl-o to open the log in vim,\nand enter to execute kubectl exec on the selected pod.\n\nexecute action allows you to ‚Äúexecute‚Äù an arbitrary command without leaving fzf, so when you‚Äôre done, you can continue browsing the logs.\n\n{1} in the bind expression denotes the first token of the current line, which is the name of the pod.\n\nLast modified: Jul 8, 2024\nCopyright ¬© 2025 Junegunn Choi\nBest practices\nExamples\nBrowsing local logs files\nBrowsing Kubernetes logs using\nstern"
  },
  {
    "id": 60493317,
    "timestamp": "2026-02-23T11:43:15.017Z",
    "title": "fzf: Search syntax | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/search-syntax/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nSearch syntax #\n\nSometimes fuzzy matching is not enough. fzf implements its own simple search syntax to augment fuzzy matching.\n\nMultiple search terms #\n\nYou can type in multiple search terms delimited by spaces. For example, fzf sees ^music .mp3$ sbtrkt !fire as four separate search terms.\n\nMatch types #\nToken\tMatch type\tDescription\nsbtrkt\tfuzzy-match\tItems that include sbtrkt characters in that order\n'wild\texact-match (quoted)\tItems that include wild\n'wild'\texact-boundary-match (quoted both ends)\tItems that include wild at word boundaries\n^music\tprefix-exact-match\tItems that start with music\n.mp3$\tsuffix-exact-match\tItems that end with .mp3\n!fire\tinverse-exact-match\tItems that do not include fire\n!^music\tinverse-prefix-exact-match\tItems that do not start with music\n!.mp3$\tinverse-suffix-exact-match\tItems that do not end with .mp3\nExact matching #\n\nIf you don‚Äôt prefer fuzzy matching and do not wish to ‚Äúquote‚Äù every word, start fzf with -e or --exact option. Note that when --exact is set, '-prefix ‚Äúunquotes‚Äù the term.\n\nOR operator #\n\nA single bar character term acts as an OR operator. For example, the following query matches entries that start with core and end with either go, rb, or py.\n\n^core go$ | rb$ | py$\n\nHow to get better results #\n\nA common mistake is to type unnecessary spaces. You may type git add to search for git add something. But if you do so, fzf sees it as two separate terms and process them separately, so it will match add ... git which is not what you want.\n\n# fzf picks up both\n\nfzf -q 'git add' << EOF\n\nadd things to git\n\ngit add something\n\nEOF\n\n\nSo most of the time, you‚Äôll get better results by typing less.\n\ngitadd is better than git add; add git will be filtered out.\ngadd should work well too.\nOr gas. fzf gives big bonus scores to the matching characters at word boundaries so acronym queries like this work surprisingly well.\nLast modified: Aug 29, 2024\nCopyright ¬© 2025 Junegunn Choi\nMultiple search terms\nMatch types\nExact matching\nOR operator\nHow to get better results"
  },
  {
    "id": 60493319,
    "timestamp": "2026-02-23T11:43:15.019Z",
    "title": "fzf: Processing multi-line items | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/tips/processing-multi-line-items/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nProcessing multi-line items #\n\nfzf is most commonly used to process single-line items like most other Unix tools. But you can also use it to process multi-line items as well and fzf is capable of properly displaying them in multi-line. To do that, you need to feed NUL-separated list to fzf and use --read0 option because a new line character can no longer be used to separate items.\n\n# Many tools provide options to output NUL-separated list\n\nfind * -print0 | fzf --read0\n\nCustomizing multi-line display #\n--gap #\n\nWhen working with multi-line items, it can be hard to visually separate consecutive items. --gap option adds a blank line between items to make it easier to distinguish them.\n\nWithout it #\nWith it #\n--highlight-line #\n\nFor multi-line items, you‚Äôll probably want --highlight-line option to highlight the entire line instead of just the text part of each line.\n\nWithout it #\nWith it #\n--marker-multi-line #\n\nIn addition to --marker, there is --marker-multi-line option to customize the ‚Äúmarker‚Äù signs for multi-line items. It takes three signs, first for the first line, second for the middle lines, and third for the last line.\n\n--marker=STR\n      Multi-select marker (default: '‚îÉ' or '>' depending on --no-unicode)\n\n--marker-multi-line=STR\n      Multi-select marker for multi-line entries. 3 elements for top, middle, and bottom.\n      (default: '‚ïª‚îÉ‚ïπ' or '.|'' depending on --no-unicode)\n\n\nThe default for --marker-multi-line was chosen so that it‚Äôs easier to visually separate consecutive multi-line items.\n\nDefault #\nCustom marker signs #\n\n--marker '‚ïê' --marker-multi-line '‚ïî‚ïë‚ïö'\n\nTransforming single-line items to multi-line #\n\nI find Perl most convenient for transforming single-line items to multi-line items. Here are some examples.\n\nAll bash/zsh functions, highlighted #\n# All bash/zsh functions, highlighted\n\ndeclare -f |\n\n  perl -0 -pe 's/^}\\n/}\\0/gm' |\n\n  bat --plain --language bash --color always |\n\n  fzf --read0 --ansi --layout reverse --multi --highlight-line --gap\n\nInput (declare)\nList all bash/zsh functions with their definitions\nPre-process (perl)\n-0 option sets the input record separator to NUL byte\nSince declare -f doesn‚Äôt print any NUL bytes, the whole output is treated as a single record\nWe inject a NUL byte after } making the chunks NUL-separated\nPre-process (bat)\nWe use bat to syntax-highlight the functions\nFilter (fzf)\n--read0 to read NUL-separated list\n--ansi to parse ANSI color codes\n--layout reverse for top-to-bottom layout\n--highlight-line to highlight the entire line instead of just the text part\n--gap for better visual separation between items\nRipgrep: multi-line chunks #\n\nWhen you use ripgrep to search for a pattern, by default it prints matching files in multi-line chunks delimited by two new line characters. For fzf to recognize each chunk as a single item, we inject NUL bytes.\n\n# Ripgrep multi-line output\n\nrg --pretty bash |\n\n  perl -0 -pe 's/\\n\\n/\\0/gm' |\n\n  fzf --read0 --ansi --multi --highlight-line --layout reverse --gap |\n\n  perl -ne '/^([0-9]+:|$)/ or print'\n\nInput (rg)\n--pretty option for colored, multi-line output\nPre-process (perl)\n-0 option to treated the input as a single record\nWith s/\\n\\n/\\0/gm, we replace two new line characters with a NUL byte.\nFilter (fzf)\n--read0 required for NUL-separated input\n--ansi to parse ANSI color codes\n--multi to allow selecting multiple items\n--highlight-line to highlight the entire line instead of just the text part\n--gap for better visual separation between items\n--layout reverse for top-to-bottom layout\nPost-process (perl)\nWe only keep the lines showing the path by filtering out the other parts.\nRipgrep: path on a separate line #\n\nIn this ripgrep example, instead of treating each multi-line chunk as a single item, we treat each matching line as a single item as we normally do. But we print the path and the line number on a separate line, so that the output is more readable on narrow screens, especially when preview window is enabled.\n\nrg --column --line-number --no-heading --color=always --smart-case -- bash |\n\n  perl -pe 's/\\n/\\0/; s/^([^:]+:){3}/$&\\n  /' |\n\n  fzf --read0 --ansi --highlight-line --multi --delimiter : \\\n\n      --preview 'bat --style=numbers --color=always --highlight-line {2} {1}' \\\n\n      --preview-window '+{2}/4' --gap |\n\n  perl -ne '/^([^:]+:){3}/ and print'\n\nInput (rg)\nFirst we use rg to search for the keyword bash in the current directory\nPre-process (perl)\nThen use Perl to replace new line characters with a NUL byte, then inject a new line character after PATH:LINE:COL: part. The matching line is indented by two spaces.\nFilter (fzf)\nIn addition to the usual --read0 and --highlight-line, we also set up preview window to show the matching line in the file in the preview window on the right. Since we specified --delimiter :, we can refer to the path and the line number with {1} and {2} respectively.\n--preview-window '+{2}/4' specifies the scroll offset of the preview window. +{2} means that the offset should be set according to the second token in the item, which is the line number. /4 means that the offset is adjusted so that the line is shown at the 1/4th of the preview window.\nPost-process (perl)\nWe only keep the PATH:LINE:COL: lines from the output\nLast modified: Jan 20, 2025\nCopyright ¬© 2025 Junegunn Choi\nCustomizing multi-line display\n--gap\n--highlight-line\n--marker-multi-line\nTransforming single-line items to multi-line\nAll bash/zsh functions, highlighted\nRipgrep: multi-line chunks\nRipgrep: path on a separate line"
  },
  {
    "id": 60493321,
    "timestamp": "2026-02-23T11:43:15.027Z",
    "title": "fzf: Using fzf in your program | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/tips/using-fzf-in-your-program/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nUsing fzf in your program #\n\nWhile fzf is most commonly used in shell scripts, you can also use it in your programs written in different languages.\n\nAs a Go library #\n\nfzf is written in Go, so you can use it as a library in your Go programs. However, the API is experimental and subject to change. I‚Äôll try to keep this gist up-to-date with the latest changes.\n\n\tpackage main\n\t\n\n\timport (\n\t\t\"fmt\"\n\t\t\"os\"\n\t\n\n\t\tfzf \"github.com/junegunn/fzf/src\"\n\t)\n\t\n\n\tfunc main() {\n\t\tinputChan := make(chan string)\n\t\tgo func() {\n\t\t\tfor _, s := range []string{\"a\", \"b\", \"c\"} {\n\t\t\t\tinputChan <- s\n\t\t\t}\n\t\t\tclose(inputChan)\n\t\t}()\n\t\n\n\t\toutputChan := make(chan string)\n\t\tgo func() {\n\t\t\tfor s := range outputChan {\n\t\t\t\tfmt.Println(\"Got: \" + s)\n\t\t\t}\n\t\t}()\n\t\n\n\t\texit := func(code int, err error) {\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\t\t}\n\t\t\tos.Exit(code)\n\t\t}\n\t\n\n\t\t// Build fzf.Options\n\t\toptions, err := fzf.ParseOptions(\n\t\t\ttrue, // whether to load defaults ($FZF_DEFAULT_OPTS_FILE and $FZF_DEFAULT_OPTS)\n\t\t\t[]string{\"--multi\", \"--reverse\", \"--border\", \"--height=40%\"},\n\t\t)\n\t\tif err != nil {\n\t\t\texit(fzf.ExitError, err)\n\t\t}\n\t\n\n\t\t// Set up input and output channels\n\t\toptions.Input = inputChan\n\t\toptions.Output = outputChan\n\t\n\n\t\t// Run fzf\n\t\tcode, err := fzf.Run(options)\n\t\texit(code, err)\n\t}\nview raw\nfzf-example.go hosted with ‚ù§ by GitHub\nIn other languages #\n\nEven if you‚Äôre not using Go, you can still use fzf in your programs as an external command. Here are some examples in different languages.\n\nRuby #\n\nWe write generic with_filter function that takes a command as the first argument and a block which produces the input to the command, and returns the selected entries as an array.\n\ndef with_filter(command)\n\n  io = IO.popen(command, 'r+')\n\n  begin\n\n    stdout, $stdout = $stdout, io\n\n    yield rescue nil\n\n  ensure\n\n    $stdout = stdout\n\n  end\n\n  io.close_write\n\n  io.readlines.map(&:chomp)\n\nend\n\n\n\nresult = with_filter('fzf -m') do\n\n  1000.times do |n|\n\n    puts n\n\n    sleep 0.005\n\n  end\n\nend\n\n\n\npp result\n\nPython #\n\nTranslated to Python.\n\nimport subprocess\n\nimport sys\n\nimport time\n\n\n\ndef with_filter(command, work):\n\n    process = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True, shell=True)\n\n    original_stdout = sys.stdout\n\n    sys.stdout = process.stdin\n\n    try:\n\n        work()\n\n        process.stdin.close()\n\n    except:\n\n        pass\n\n    finally:\n\n        sys.stdout = original_stdout\n\n\n\n    output = process.stdout.read().splitlines()\n\n    process.stdout.close()\n\n    return output\n\n\n\ndef work():\n\n    for n in range(1000):\n\n        print(n, flush=True)\n\n        time.sleep(0.005)\n\n\n\nprint(with_filter('fzf -m', work))\n\nClojure #\n\nWe do the same with Clojure. The code here is a bit more involved, but it will give you a hint on how it can be done in other JVM languages.\n\n(require '[clojure.java.io :as io])\n\n\n\n(defmacro with-filter\n\n  [command & forms]\n\n  `(let [sh#  (or (System/getenv \"SHELL\") \"sh\")\n\n         pb#  (ProcessBuilder. [sh# \"-c\" ~command])\n\n         p#   (.start pb#)\n\n         in#  (io/reader (.getInputStream p#))\n\n         out# (io/writer (.getOutputStream p#))]\n\n     (binding [*out* out#]\n\n       (try ~@forms (.close out#) (catch Exception e#)))\n\n     (take-while identity (repeatedly #(.readLine in#)))))\n\n\n\n(let [result (with-filter \"fzf -m\"\n\n               (dotimes [n 1000]\n\n                 (println n)\n\n                 (Thread/sleep 5)))]\n\n  (println result))\n\nLast modified: Jun 5, 2024\nCopyright ¬© 2025 Junegunn Choi\nAs a Go library\nIn other languages\nRuby\nPython\nClojure"
  },
  {
    "id": 60493320,
    "timestamp": "2026-02-23T11:43:15.027Z",
    "title": "fzf: Ripgrep integration, a walkthrough | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/tips/ripgrep-integration/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nRipgrep integration, a walkthrough #\nThe two pillars of fzf #\n\nThe interactive terminal interface and the fuzzy matching algorithm are the two pillars of fzf. However, the usefulness of the latter is rather limited in a non-interactive environment. This is because by its very nature, it generates irrelevant matches and user confirmation is almost always necessary.\n\nfzf --filter lt < /usr/share/dict/words | head -5\n\n  # lat\n\n  # let\n\n  # lit\n\n  # lot\n\n  # Lot\n\n\n‚ÄúThese are all good matches for ‚Äôlt‚Äô, but which one is truly the right one?‚Äù\n\nfzf --filter lt < /usr/share/dict/words | tail -5\n\n  # philosophicojuristic\n\n  # blepharoconjunctivitis\n\n  # sulphureovirescent\n\n  # blepharosyndesmitis\n\n  # choledochoduodenostomy\n\n\n‚ÄúYou‚Äôre definitely not interested in these. But are you?‚Äù\n\nThe interactive terminal interface, on the other hand, can still be useful even if you don‚Äôt want the fuzzy matching algorithm of fzf and want to use an external program or service to do the filtering.\n\nRipgrep is a good example. It‚Äôs obviously a much better choice for searching for a pattern in a large number of files. But it‚Äôs not an interactive program. You can‚Äôt change the search pattern on the fly.\n\nWe can get the best of both worlds by combining ripgrep with the interactive interface of fzf. This article will show you how to achieve that step by step.\n\nWalkthrough #\n1. --disabled #\n\nTo prevent fzf from doing the filtering, we use --disabled option.\n\nfzf --disabled\n\n\nNow fzf is a mere selector interface. You can move the cursor up and down and select an item from the list, but that‚Äôs it. Anything you type on the prompt is simply ignored.\n\n2. Bind change event #\n\nWe need a way to relaunch ripgrep whenever the query string is changed. The ‚Äúevent-action binding mechanism‚Äù of fzf is the answer. We‚Äôre going to bind change event, which is triggered when the query string is changed, to reload action that runs a command and replaces the current list with the output of the command.\n\nRun this command and type anything.\n\nfzf --disabled --bind 'change:reload:echo you typed {q}'\n\n{q} is the placeholder expression for the current query, single-quoted.\n\nSee? Let‚Äôs replace echo with rg, run the command, and type in a search pattern.\n\nfzf --disabled --bind 'change:reload:rg {q}'\n\n\nIt‚Äôs a good start, but there‚Äôs a lot to be desired.\n\nNo line and column numbers are shown.\nNo colors.\nSearch is case-sensitive, which is not what you‚Äôd expect from fzf.\nThe initial list is a list of files. We need to start fzf with a ripgrep result for the initial query.\nNo preview window.\nNo action performed when you press enter. fzf just prints the selected line.\n3. Set ripgrep options #\nAdd --column to show both line and column numbers.\nAdd --color=always to show colors. This requires --ansi option of fzf.\nAdd --smart-case to make the search case-insensitive by default, but case-sensitive if the query contains an uppercase letter.\nfzf --disabled --ansi \\\n\n    --bind 'change:reload:rg --column --color=always --smart-case {q}'\n\n4. Fix initial list #\n\nAs mentioned above, the above command starts fzf with a list of files because no input is fed to it and fzf starts its built-in directory walker. Let‚Äôs fix it.\n\nrg --column --color=always --smart-case '' |\n\n  fzf --disabled --ansi \\\n\n      --bind 'change:reload:rg --column --color=always --smart-case {q}'\n\n\nOkay, but we‚Äôre repeating the same command twice. Let‚Äôs put it in a variable and refer to it. Instead of feeding the output of the command to fzf via standard input, let‚Äôs bind start event to reload action for consistency.\n\n(RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n fzf --disabled --ansi \\\n\n     --bind \"start:$RELOAD\" --bind \"change:$RELOAD\")\n\nWe start subshell (...) not to pollute the current shell environment with temporary variables.\nNotice the || : at the end of the command. This is to prevent the command from exiting with a non-zero status when there‚Äôs no match for the pattern. Otherwise, fzf will show [Command failed: rg --column --color=always --smart-case '...'] message on screen.\nstart:reload will immediately replace the initial list.\n5. Add preview window #\n\nWe‚Äôre going to use bat to show syntax-highlighted preview of the line in the file. You can install it with brew install bat.\n\n(RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n fzf --disabled --ansi \\\n\n     --bind \"start:$RELOAD\" --bind \"change:$RELOAD\" \\\n\n     --delimiter : \\\n\n     --preview 'bat --style=numbers --color=always --highlight-line {2} {1}' \\\n\n     --preview-window '+{2}/2')\n\nEach line of ripgrep output is in the format of FILEPATH:LINE:COLUMN:LINE_CONTENT. We need FILEPATH and LINE to build a preview command. To do that, we set --delimiter : and refer to the fields with {1} and {2}.\n--preview-window '+{2}/2' specifies the scroll offset of the preview window. +{2} means that the offset should be set according to the second token, which is the line number. /2 means that the offset should be adjusted so that the line is shown in the middle of the window.\n\nNice, but we can still do better.\n\n(RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n fzf \n\n     --disabled --ansi \\\n\n     --bind \"start:$RELOAD\" --bind \"change:$RELOAD\" \\\n\n     --delimiter : \\\n\n     --preview 'bat --style=full --color=always --highlight-line {2} {1}' \\\n\n     --preview-window '~4,+{2}+4/3,<80(up)')\n\nNow we‚Äôve switched to --style=full which shows the file name and the size as the header.\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n       ‚îÇ File: LICENSE\n       ‚îÇ Size: 1.1 KB\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1   ‚îÇ The MIT License (MIT)\n   2   ‚îÇ\n   3   ‚îÇ Copyright (c) 2013-2024 Junegunn Choi\n\nLet‚Äôs break down the even more cryptic --preview-window expression.\n~4 makes the top four lines ‚Äústicky‚Äù header so that they are always visible regardless of the scroll offset. (Did I mention that you can scroll the preview window with your mouse/trackpad?)\n+{2} ‚Äî The base offset is extracted from the second token\n+4 ‚Äî We add 4 lines to the base offset to compensate for the header\n/3 adjusts the offset so that the matching line is shown at a third position in the window\n<80(up) ‚Äî This expression specifies the alternative options for the preview window. By default, the preview window opens on the right side with 50% width. But if the width is narrower than 80 columns, it will open above the main window with 50% height.\n6. Bind enter to become action #\n(RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n fzf --disabled --ansi \\\n\n     --bind \"start:$RELOAD\" --bind \"change:$RELOAD\" \\\n\n     --bind 'enter:become:vim {1} +{2}' \\\n\n     --delimiter : \\\n\n     --preview 'bat --style=full --color=always --highlight-line {2} {1}' \\\n\n     --preview-window '~4,+{2}+4/3,<80(up)')\n\n\nWith the new binding, when you press enter, fzf will open the file ({1}) in vim and move the cursor to the line ({2}).\n\n7. Add another execute binding #\n\nSometimes you may want to open the file in the editor and come back to fzf to continue searching. Let‚Äôs add an execute binding for that.\n\n(RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n fzf --disabled --ansi \\\n\n     --bind \"start:$RELOAD\" --bind \"change:$RELOAD\" \\\n\n     --bind 'enter:become:vim {1} +{2}' \\\n\n     --bind 'ctrl-o:execute:vim {1} +{2}' \\\n\n     --delimiter : \\\n\n     --preview 'bat --style=full --color=always --highlight-line {2} {1}' \\\n\n     --preview-window '~4,+{2}+4/3,<80(up)')\n\n\nNow you can press ctrl-o to open the file in vim without leaving fzf.\n\n8. Handle multiple selections #\n\nSo far, we‚Äôve been dealing with a single selection. Let‚Äôs add --multi option so you can select multiple lines with TAB and SHIFT-TAB.\n\n(RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n OPENER='if [[ $FZF_SELECT_COUNT -eq 0 ]]; then\n\n           vim {1} +{2}     # No selection. Open the current line in Vim.\n\n         else\n\n           vim +cw -q {+f}  # Build quickfix list for the selected items.\n\n         fi'\n\n fzf --disabled --ansi --multi \\\n\n     --bind \"start:$RELOAD\" --bind \"change:$RELOAD\" \\\n\n     --bind \"enter:become:$OPENER\" \\\n\n     --bind \"ctrl-o:execute:$OPENER\" \\\n\n     --bind 'alt-a:select-all,alt-d:deselect-all,ctrl-/:toggle-preview' \\\n\n     --delimiter : \\\n\n     --preview 'bat --style=full --color=always --highlight-line {2} {1}' \\\n\n     --preview-window '~4,+{2}+4/3,<80(up)')\n\nfzf exports a number of environment variables to its child processes so that they can behave differently depending on the context. $FZF_SELECT_COUNT is the number of selected items.\n$OPENER holds a shell code that is run on enter and ctrl-o. It behaves differently depending on $FZF_SELECT_COUNT.\nIt builds the quickfix list for the selected items and open it only when the user has selected any items using TAB or SHIFT-TAB.\nvim +cw -q {+f} needs some explanation.\n+cw tells Vim to execute :cw command to open the quickfix window.\n-q {+f} makes Vim start in quickfix mode using the error file {+f}\nSo what is {+f}? It‚Äôs a placeholder expression of fzf for a temporary file containing the selected items. It‚Äôs a combination of two flags, + and f. See man fzf for more information.\nWe added three more bindings for convenience; alt-a and alt-d, to select and deselect all items, and ctrl-/ to toggle the preview window.\nWrap-up #\n\nLet‚Äôs define it as a function so we can pass the initial query as an argument.\n\n# ripgrep->fzf->vim [QUERY]\n\nrfv() (\n\n  RELOAD='reload:rg --column --color=always --smart-case {q} || :'\n\n  OPENER='if [[ $FZF_SELECT_COUNT -eq 0 ]]; then\n\n            vim {1} +{2}     # No selection. Open the current line in Vim.\n\n          else\n\n            vim +cw -q {+f}  # Build quickfix list for the selected items.\n\n          fi'\n\n  fzf --disabled --ansi --multi \\\n\n      --bind \"start:$RELOAD\" --bind \"change:$RELOAD\" \\\n\n      --bind \"enter:become:$OPENER\" \\\n\n      --bind \"ctrl-o:execute:$OPENER\" \\\n\n      --bind 'alt-a:select-all,alt-d:deselect-all,ctrl-/:toggle-preview' \\\n\n      --delimiter : \\\n\n      --preview 'bat --style=full --color=always --highlight-line {2} {1}' \\\n\n      --preview-window '~4,+{2}+4/3,<80(up)' \\\n\n      --query \"$*\"\n\n)\n\n\nIsn‚Äôt it wonderful? With ripgrep, bat, and fzf, we have a fully functional, high performance code search interface with syntax-highlighted live preview that integrates with Vim in less than 20 lines of code. This is the beauty of the Unix philosophy. And fzf is a good citizen of the Unix world.\n\nLast modified: Jun 10, 2025\nCopyright ¬© 2025 Junegunn Choi\nThe two pillars of fzf\nWalkthrough\n1. --disabled\n2. Bind change event\n3. Set ripgrep options\n4. Fix initial list\n5. Add preview window\n6. Bind enter to become action\n7. Add another execute binding\n8. Handle multiple selections\nWrap-up"
  },
  {
    "id": 60493322,
    "timestamp": "2026-02-23T11:43:15.027Z",
    "title": "fzf: Directory navigation | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/examples/directory-navigation/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nDirectory navigation with fzf #\n\nALT-C binding allows you to easily move to a subdirectory. But for directories not under the current directory, we need a different approach. Fuzzy completion helps (e.g. cd ../../foo/**<TAB>), but that‚Äôs still a lot of typing.\n\nYou definitely need a program that keeps track of the directories you visit frequently and allows you to jump between them quickly. It will immensly boost your productivity, because you‚Äôll be switching between a small number of directories most of the time.\n\nz #\n\nI‚Äôve been using the good old z. There are alternatives like autojump and zoxide, but I prefer the simplicity of z and the fact that it‚Äôs just a small shell script file so I can easily read and change if needed. Other projects claim to be faster, but performance is rarely an issue and you won‚Äôt really notice the difference.\n\nInstallation #\n\nInstalling z is easy. You can use your package manager to install it\n\nbrew install z\n\n\nor download the script file.\n\ncurl https://raw.githubusercontent.com/rupa/z/master/z.sh -o ~/.z.sh\n\n\nThen add a line to your shell configuration file to source the script.\n\n# If installed via Homebrew\n\necho \". /opt/homebrew/etc/profile.d/z.sh\" >> ~/.bashrc\n\n\n\n# If downloaded manually\n\necho \". ~/.z.sh\" >> ~/.bashrc\n\nUsage #\n\nOnce set up, z will keep track of the directories you visit and sort them by ‚Äúfrecency‚Äù (frequency + recency). You can jump to the most ‚Äúrelevant‚Äù directory matching the given string.\n\nz foo\n\n\nOr you can list the directories by just typing z\n\nz\n\nIntegration with fzf #\n\nNow that we have a list of relevant directories you visit all the time, it‚Äôs time to integrate it with fzf.\n\nz actually is an alias to _z function. Let‚Äôs unalias it first to create our own z function that integrates with fzf.\n\nunalias z 2> /dev/null\n\n\nThen we define our z function like so:\n\nz() {\n\n  local dir=$(\n\n    _z 2>&1 |\n\n    fzf --height 40% --layout reverse --info inline \\\n\n        --nth 2.. --tac --no-sort --query \"$*\" \\\n\n        --accept-nth 2..\n\n  ) && cd \"$dir\"\n\n}\n\n_z prints the list to the standard error, so we redirect it to the standard output (2>&1).\n--height 40% --layout reverse --info inline\nThese options just customize the layout and don‚Äôt affect the result, so feel free to experiment with other options. fzf Theme Generator is a great place to explore different options.\n--nth 2.. limits the search scope to exclude the first score column.\n_z lists the entries in the ascending order of the score, so we use --tac to make the most relevant entry appear first.\nBecause the list is already sorted, we use --no-sort.\n--query \"$*\" sets the initial query to the arguments passed to the function.\nBy default, when you press enter, fzf prints the entire line to the standard output. But we only want the directory name without the score at the front, so we use --accept-nth 2.. to change the behavior.\nWe use 2.. instead of 2 in case the directory name contains spaces.\nzoxide #\n\nzoxide is an alternative to z. It provides fzf integration out of the box as zi (zoxide interactive). However, the options to fzf are not customizable and fuzzy matching is disabled, so you might want to define your own function like the one above. We simply replace _z 2>&1 with zoxide query --list --score, and that‚Äôs all it takes.\n\nz() {\n\n  local dir=$(\n\n    zoxide query --list --score |\n\n    fzf --height 40% --layout reverse --info inline \\\n\n        --nth 2.. --tac --no-sort --query \"$*\" \\\n\n        --bind 'enter:become:echo {2..}'\n\n  ) && cd \"$dir\"\n\n}\n\nLast modified: May 6, 2025\nCopyright ¬© 2025 Junegunn Choi\nz\nInstallation\nUsage\nIntegration with fzf\nzoxide"
  },
  {
    "id": 60493325,
    "timestamp": "2026-02-23T11:43:15.033Z",
    "title": "fzf: Tmux integration | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/examples/tmux/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nTmux integration #\nTmux plugins #\n\nThere are tmux plugins that utilize fzf for better experience.\n\njunegunn/tmux-fzf-url #\n\nThe one I enjoy the most is junegunn/tmux-fzf-url. It allows me to quickly open URLs in the browser with just a few key strokes. Highly recommended.\n\nsainnhe/tmux-fzf #\n\nsainnhe/tmux-fzf allows you to perform various actions on tmux using fzf. It‚Äôs probably the most feature-rich plugin out there so you might want to check it out.\n\nLast modified: Sep 1, 2024\nCopyright ¬© 2025 Junegunn Choi\nTmux plugins\njunegunn/tmux-fzf-url\nsainnhe/tmux-fzf"
  },
  {
    "id": 60493324,
    "timestamp": "2026-02-23T11:43:15.034Z",
    "title": "fzf: Completing Git objects with fzf | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/examples/git/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nCompleting Git objects with fzf #\n\nIf you‚Äôre like me and you prefer to write Git commands by hand, you often need to type in commit hashes, branch names, tags, etc. And fzf can really help you with that.\n\nWith its numerous subcommands and options, git can be quite daunting even for the experienced. There is sophisticated, context-aware completion support for git command, but I find it lacking in several aspects.\n\nThe ‚Äúcontext-awareness‚Äù of it definitely helps, but in some cases it can be limiting. For example, for git checkout, it lists branches and tags, but I sometimes need to check out a specific commit by its commit hash (a.k.a. detached head state).\nWe can‚Äôt tell whether a completion candidate is a tag, or a branch. We don‚Äôt see the details of each entry, just the names.\nEven if the completion for git checkout is extended to also present commit hashes as the candidates, it will be hardly useful, as we have no way of knowing what each hash represents.\nIt only works with git command, you can‚Äôt use it in other contexts.\n\nSo in addition to the completion, I use a set of dedicated key bindings for each type of git object; commit hashes, branches, tags, remotes, and the files that are modified or untracked, etc.\n\nCTRL-G CTRL-F for Files\nCTRL-G CTRL-B for Branches\nCTRL-G CTRL-T for Tags\nCTRL-G CTRL-R for Remotes\nCTRL-G CTRL-H for commit Hashes\nCTRL-G CTRL-S for Stashes\nCTRL-G CTRL-L for reflogs\nCTRL-G CTRL-W for Worktrees\nCTRL-G CTRL-E for Each ref (git for-each-ref)\n\nThey are implemented using fzf, so we can interactively search for things with its efficient fuzzy matching algorithm, and with the --preview option, we not only see the list of the objects, but also the details of each entry, without having to run additional commands.\n\nThe bindings are available in fzf-git.sh respository. Thank me later.\n\nLast modified: Aug 24, 2024\nCopyright ¬© 2025 Junegunn Choi"
  },
  {
    "id": 60493323,
    "timestamp": "2026-02-23T11:43:15.035Z",
    "title": "fzf: Browsing Chrome history and bookmarks with fzf | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/examples/chrome/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\nBrowsing Chrome history and bookmarks with fzf #\n\nInfo\n\nYou might want to check out https://github.com/junegunn/everything.fzf which includes a more complete version of this script, along with many other integrations.\n\nIn this example, you‚Äôll learn how to browse Chrome history and bookmarks from the command-line using fzf.\n\nGetting the input data #\n\nChrome manages the browsing history in an SQLite database file, and the bookmarks in a JSON file. For example, on macOS, the files are located at:\n\n~/Library/Application Support/Google/Chrome/Default/History\n# The file is locked if Chrome is running, so you need to make a copy\n\ncp ~/Library/Application\\ Support/Google/Chrome/Default/History /tmp/h\n\n\n\nsqlite3 /tmp/h '.schema urls'\n\nCREATE TABLE urls(\n\n  id              INTEGER PRIMARY KEY AUTOINCREMENT,\n\n  url             LONGVARCHAR,\n\n  title           LONGVARCHAR,\n\n  visit_count     INTEGER DEFAULT 0 NOT NULL,\n\n  typed_count     INTEGER DEFAULT 0 NOT NULL,\n\n  last_visit_time INTEGER NOT NULL,\n\n  hidden          INTEGER DEFAULT 0 NOT NULL\n\n);\n\nCREATE INDEX urls_url_index ON urls (url);\n\n~/Library/Application Support/Google/Chrome/Default/Bookmarks\njq '.roots | keys' ~/Library/Application\\ Support/Google/Chrome/Default/Bookmarks\n\n[\n\n  \"bookmark_bar\",\n\n  \"other\",\n\n  \"synced\"\n\n]\n\n\nWhile it‚Äôs not impossible to process these files using shell script, it‚Äôs challenging and probably not worth the effort, especially because the bookmarks are in hierarchical structure. A scripting language like Ruby, Python, or Perl would be better suited for this task. I‚Äôve chosen Ruby for this example because I‚Äôm most comfortable with it, but any language of your choice will do.\n\nSee Using fzf in your program to learn how to integrate fzf into your program.\n\nIntegration ideas #\nAllow selecting multiple items and open them all at once\n--multi (tab and shift-tab to select multiple items)\nEnable line wrapping so that long URLs are not truncated\n--wrap\nUse multi-line feature of fzf to display the title of the page and the URL in separate lines\n--read0\nPrint the title and the URL in different colors\n--ansi\nOpen the selected URLs when you hit Enter, but do not close fzf so you can continue browsing\n--bind enter:execute-silent(...)+deselect-all\nShow the current mode in the border label\n--border-label \" Chrome::History \"\nProvide bindings to switch between history mode and bookmarks mode\n--bind ctrl-b:reload(...)+change-border-label(...)+top\n--bind ctrl-h:reload(...)+change-border-label(...)+top\nProvide a binding to copy the selected URLs to the clipboard\n--bind ctrl-y:execute-silent(...)+deselect-all\nScreenshot #\nThe code #\n\nStore the following code in a file, say chrome.fzf, put in in your $PATH, and make it executable, so you can run it from anywhere.\n\nThe script was only tested on macOS, so if you‚Äôre on another platform, you may need to change OPEN_COMMAND and CLIP_COMMAND to the commands that work on your platform.\n\n  1\n#!/usr/bin/env ruby\n\n  2\n# frozen_string_literal: true\n\n  3\n\n\n  4\nrequire 'bundler/inline'\n\n  5\nrequire 'rbconfig'\n\n  6\nrequire 'tempfile'\n\n  7\nrequire 'json'\n\n  8\nrequire 'open3'\n\n  9\nrequire 'shellwords'\n\n 10\n\n\n 11\ngemfile do\n\n 12\n  source 'https://rubygems.org'\n\n 13\n  gem 'sqlite3'\n\n 14\n  gem 'ansi256'\n\n 15\nend\n\n 16\n\n\n 17\n# Chrome fzf integration\n\n 18\nmodule ChromeFzf\n\n 19\n  extend self\n\n 20\n\n\n 21\n  # Platform-specific constants.\n\n 22\n  # FIXME: Commands for Linux and Windows are not tested.\n\n 23\n  BASE_PATH, OPEN_COMMAND, CLIP_COMMAND =\n\n 24\n    case RbConfig::CONFIG['host_os']\n\n 25\n    when /darwin/\n\n 26\n      ['Library/Application Support/Google/Chrome', 'open {+2}', 'echo -n {+2} | pbcopy']\n\n 27\n    when /linux/\n\n 28\n      ['.config/google-chrome', 'xdg-open {+2}', 'echo -n {+2} | xsel --clipboard --input']\n\n 29\n    else\n\n 30\n      ['AppData\\Local\\Google\\Chrome\\User Data', 'start {+2}', 'echo {+2} | clip']\n\n 31\n    end\n\n 32\n\n\n 33\n  def run(type)\n\n 34\n    Open3.popen2(fzf(type)) do |stdin, _stdout|\n\n 35\n      list(type, stdin)\n\n 36\n    end\n\n 37\n  rescue Errno::EPIPE\n\n 38\n    # Ignore broken pipe error\n\n 39\n  end\n\n 40\n\n\n 41\n  def list(type, io = $stdout)\n\n 42\n    method(type).call.each do |title, url, time|\n\n 43\n      format(io, title, url, time)\n\n 44\n    end\n\n 45\n  end\n\n 46\n\n\n 47\n  private\n\n 48\n\n\n 49\n  def path(name) = File.join(Dir.home, BASE_PATH, 'Default', name)\n\n 50\n\n\n 51\n  # Build fzf command\n\n 52\n  def fzf(name)\n\n 53\n    <<~CMD\n\n 54\n      fzf --ansi --read0 --multi --info inline-right --reverse --scheme history \\\\\n\n 55\n          --highlight-line --cycle --tmux 100% --wrap --wrap-sign ' ‚Ü≥ ' \\\\\n\n 56\n          --border --border-label \" Chrome::#{name.capitalize} \" --delimiter \"\\n ¬∑ \" \\\\\n\n 57\n          --header '‚ï± CTRL-B: Bookmarks ‚ï± CTRL-H: History ‚ï± CTRL-Y: Copy to clipboard ‚ï±\\n\\n' \\\\\n\n 58\n          --bind 'enter:execute-silent(#{OPEN_COMMAND})+deselect-all' \\\\\n\n 59\n          --bind 'ctrl-y:execute-silent(#{CLIP_COMMAND})+deselect-all' \\\\\n\n 60\n          --bind 'ctrl-b:reload(ruby #{__FILE__.shellescape} --list b)+change-border-label( Chrome::Bookmarks )+top' \\\\\n\n 61\n          --bind 'ctrl-h:reload(ruby #{__FILE__.shellescape} --list h)+change-border-label( Chrome::History )+top'\n\n 62\n    CMD\n\n 63\n  end\n\n 64\n\n\n 65\n  def format(io, title, url, time)\n\n 66\n    time = Time.at(time.to_i / 1_000_000 - 11_644_473_600).strftime('%F %T')\n\n 67\n    io.puts \"#{title} (#{time.yellow})\".strip\n\n 68\n    io.print \" ¬∑ #{url.blue.dim}\\n\\x0\"\n\n 69\n  end\n\n 70\n\n\n 71\n  def history\n\n 72\n    Tempfile.create('chrome') do |temp|\n\n 73\n      temp.close\n\n 74\n      FileUtils.cp(path('History'), temp.path)\n\n 75\n      SQLite3::Database.open(temp.path) do |db|\n\n 76\n        db.execute('select title, url, last_visit_time from urls order by last_visit_time desc')\n\n 77\n      end\n\n 78\n    end\n\n 79\n  end\n\n 80\n\n\n 81\n  def bookmarks\n\n 82\n    build = lambda do |parent, json|\n\n 83\n      name = [parent, json[:name]].compact.join('/')\n\n 84\n      if json[:type] == 'folder'\n\n 85\n        json[:children].flat_map { |child| build[name, child] }\n\n 86\n      else\n\n 87\n        [[name, json[:url], json.values_at(:date_last_used, :date_added).max]]\n\n 88\n      end\n\n 89\n    end\n\n 90\n\n\n 91\n    JSON.load_file(path('Bookmarks'), symbolize_names: true)\n\n 92\n        .fetch(:roots, {})\n\n 93\n        .values\n\n 94\n        .flat_map { |e| build[nil, e] }\n\n 95\n        .sort_by(&:last)\n\n 96\n        .reverse\n\n 97\n  end\n\n 98\nend\n\n 99\n\n\n100\nmethod = ARGV.delete('--list') ? :list : :run\n\n101\ntype = case ARGV[0]&.downcase\n\n102\n       when 'b' then :bookmarks\n\n103\n       when 'h', nil then :history\n\n104\n       else abort \"Usage: #{__FILE__} [--list] [b|h]\"\n\n105\n       end\n\n106\n\n\n107\nChromeFzf.send(method, type)\n\n\nNote\n\nIn both cases, the entries are sorted by the last visit time in descending order. We use --scheme history to give more weight to this ordering.\nIf you don‚Äôt want to keep fzf open after you press enter or CTRL-Y, change execute-silent(...)+deselect-all to enter:become(...).\nLast modified: Jun 10, 2025\nCopyright ¬© 2025 Junegunn Choi\nGetting the input data\nIntegration ideas\nScreenshot\nThe code"
  },
  {
    "id": 60493326,
    "timestamp": "2026-02-23T11:43:15.041Z",
    "title": "fzf: everything.fzf | junegunn.choi.",
    "url": "https://junegunn.github.io/fzf/examples/everything.fzf/",
    "text": "junegunn.choi.\nfzf\nInstallation\nGetting Started\nShell Integration\nSearch syntax\nRelease Highlights\nTips\nBrowsing log streams\nProcessing multi-line items\nRipgrep integration\nUsing fzf in your program\nExamples\nDirectory navigation\nChrome history\nGit objects\nTmux integration\neverything.fzf\nvim-plug\n\nLast modified: May 6, 2025\nCopyright ¬© 2025 Junegunn Choi"
  }
]
