[
  {
    "id": 259006892,
    "timestamp": "2026-02-26T22:35:47.596Z",
    "title": "Headless Browser Automation for AI",
    "url": "https://agent-browser.dev/",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nagent-browser\n\nBrowser automation CLI designed for AI agents. Compact text output minimizes context usage. Fast Rust CLI with Node.js fallback.\n\nnpm install -g agent-browser      # all platforms (fastest, native Rust CLI)\nbrew install agent-browser        # macOS\n\n# or try without installing\nnpx agent-browser open example.com\nFEATURES\nAgent-first - Compact text output uses fewer tokens than JSON, designed for AI context efficiency\nRef-based - Snapshot returns accessibility tree with refs for deterministic element selection\nFast - Native Rust CLI for instant command parsing\nComplete - 50+ commands for navigation, forms, screenshots, network, storage\nSessions - Multiple isolated browser instances with separate auth\nCross-platform - macOS, Linux, Windows with native binaries\nWORKS WITH\n\nClaude Code, Cursor, GitHub Copilot, OpenAI Codex, Google Gemini, opencode, and any agent that can run shell commands.\n\nEXAMPLE\n# Navigate and get snapshot\nagent-browser open example.com\nagent-browser snapshot -i\n\n# Output:\n# - heading \"Example Domain\" [ref=e1]\n# - link \"More information...\" [ref=e2]\n\n# Interact using refs\nagent-browser click @e2\nagent-browser screenshot page.png\nagent-browser close\nWHY REFS?\n\nThe snapshot command returns a compact accessibility tree where each element has a unique ref like @e1, @e2. This provides:\n\nContext-efficient - Text output uses ~200-400 tokens vs ~3000-5000 for full DOM\nDeterministic - Ref points to exact element from snapshot\nFast - No DOM re-query needed\nAI-friendly - LLMs parse text output naturally\nARCHITECTURE\n\nClient-daemon architecture for optimal performance:\n\nRust CLI - Parses commands, communicates with daemon\nNode.js Daemon - Manages Playwright browser instance\n\nDaemon starts automatically and persists between commands.\n\nPLATFORMS\n\nNative Rust binaries for macOS (ARM64, x64), Linux (ARM64, x64), and Windows (x64).\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006896,
    "timestamp": "2026-02-26T22:35:47.596Z",
    "title": "Installation | agent-browser",
    "url": "https://agent-browser.dev/installation",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nInstallation\nGLOBAL INSTALLATION (RECOMMENDED)\n\nInstalls the native Rust binary for maximum performance:\n\nnpm install -g agent-browser\nagent-browser install  # Download Chromium\n\nThis is the fastest option -- commands run through the native Rust CLI directly with sub-millisecond parsing overhead.\n\nQUICK START (NO INSTALL)\n\nRun directly with npx if you want to try it without installing globally:\n\nnpx agent-browser install   # Download Chromium (first time only)\nnpx agent-browser open example.com\n\nNote: npx routes through Node.js before reaching the Rust CLI, so it is noticeably slower than a global install. For regular use, install globally.\n\nPROJECT INSTALLATION (LOCAL DEPENDENCY)\n\nFor projects that want to pin the version in package.json:\n\nnpm install agent-browser\nnpx agent-browser install\n\nThen use via npx or package.json scripts:\n\nnpx agent-browser open example.com\nHOMEBREW (MACOS)\nbrew install agent-browser\nagent-browser install  # Download Chromium\nFROM SOURCE\ngit clone https://github.com/vercel-labs/agent-browser\ncd agent-browser\npnpm install\npnpm build\npnpm build:native\n./bin/agent-browser install\npnpm link --global\nLINUX DEPENDENCIES\n\nOn Linux, install system dependencies:\n\nagent-browser install --with-deps\n# or manually: npx playwright install-deps chromium\nCUSTOM BROWSER\n\nUse a custom browser executable instead of bundled Chromium:\n\nServerless - Use @sparticuz/chromium (~50MB vs ~684MB)\nSystem browser - Use existing Chrome installation\nCustom builds - Use modified browser builds\n# Via flag\nagent-browser --executable-path /path/to/chromium open example.com\n\n# Via environment variable\nAGENT_BROWSER_EXECUTABLE_PATH=/path/to/chromium agent-browser open example.com\nServerless example\nimport chromium from '@sparticuz/chromium';\nimport { BrowserManager } from 'agent-browser';\n\nexport async function handler() {\n  const browser = new BrowserManager();\n  await browser.launch({\n    executablePath: await chromium.executablePath(),\n    headless: true,\n  });\n  // ... use browser\n}\nAI AGENT SETUP\n\nagent-browser works with any AI agent out of the box. For richer context:\n\nAI coding assistants (recommended)\n\nInstall the skill for your AI coding assistant:\n\nnpx skills add vercel-labs/agent-browser\n\nThis works with Claude Code, Codex, Cursor, Gemini CLI, GitHub Copilot, Goose, OpenCode, and Windsurf. The skill is fetched from the repository and stays up to date automatically.\n\nDo not copy SKILL.md from node_modules -- it will become stale as new features are added. Always use npx skills add or reference the repository version.\n\nAGENTS.md / CLAUDE.md\n\nAdd to your instructions file:\n\n## Browser Automation\n\nUse `agent-browser` for web automation. Run `agent-browser --help` for all commands.\n\nCore workflow:\n1. `agent-browser open <url>` - Navigate to page\n2. `agent-browser snapshot -i` - Get interactive elements with refs (@e1, @e2)\n3. `agent-browser click @e1` / `fill @e2 \"text\"` - Interact using refs\n4. Re-snapshot after page changes\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006889,
    "timestamp": "2026-02-26T22:35:47.597Z",
    "title": "agent-browser/README.md at main · vercel-labs/agent-browser",
    "url": "https://github.com/vercel-labs/agent-browser/blob/main/README.md",
    "text": "Skip to content\nvercel-labs\nagent-browser\nType / to search\nRepository navigation\nCode\nIssues\n125\n (125)\nPull requests\n105\n (105)\nActions\nProjects\nSecurity\nInsights\nFiles\n main\nt\n.agents\n.changeset\n.claude-plugin\n.github\n.husky\nbin\ncli\ndocker\ndocs\nscripts\nskills\nsrc\ntest\n.gitignore\n.prettierrc\nAGENTS.md\nCHANGELOG.md\nLICENSE\nREADME.md\npackage.json\npnpm-lock.yaml\ntsconfig.json\nvitest.config.ts\nBreadcrumbs\nagent-browser\n/README.md\nLatest commit\nctate\nadd security hardening features (#543)\nbc1e917\n · \nHistory\nHistory\nFile metadata and controls\nPreview\nCode\nBlame\n1156 lines (865 loc) · 39.3 KB\nRaw\nagent-browser\n\nHeadless browser automation CLI for AI agents. Fast Rust CLI with Node.js fallback.\n\nInstallation\nGlobal Installation (recommended)\n\nInstalls the native Rust binary for maximum performance:\n\nnpm install -g agent-browser\nagent-browser install  # Download Chromium\n\nThis is the fastest option -- commands run through the native Rust CLI directly with sub-millisecond parsing overhead.\n\nQuick Start (no install)\n\nRun directly with npx if you want to try it without installing globally:\n\nnpx agent-browser install   # Download Chromium (first time only)\nnpx agent-browser open example.com\n\nNote: npx routes through Node.js before reaching the Rust CLI, so it is noticeably slower than a global install. For regular use, install globally.\n\nProject Installation (local dependency)\n\nFor projects that want to pin the version in package.json:\n\nnpm install agent-browser\nnpx agent-browser install\n\nThen use via npx or package.json scripts:\n\nnpx agent-browser open example.com\nHomebrew (macOS)\nbrew install agent-browser\nagent-browser install  # Download Chromium\nFrom Source\ngit clone https://github.com/vercel-labs/agent-browser\ncd agent-browser\npnpm install\npnpm build\npnpm build:native   # Requires Rust (https://rustup.rs)\npnpm link --global  # Makes agent-browser available globally\nagent-browser install\nLinux Dependencies\n\nOn Linux, install system dependencies:\n\nagent-browser install --with-deps\n# or manually: npx playwright install-deps chromium\nQuick Start\nagent-browser open example.com\nagent-browser snapshot                    # Get accessibility tree with refs\nagent-browser click @e2                   # Click by ref from snapshot\nagent-browser fill @e3 \"test@example.com\" # Fill by ref\nagent-browser get text @e1                # Get text by ref\nagent-browser screenshot page.png\nagent-browser close\nTraditional Selectors (also supported)\nagent-browser click \"#submit\"\nagent-browser fill \"#email\" \"test@example.com\"\nagent-browser find role button click --name \"Submit\"\nCommands\nCore Commands\nagent-browser open <url>              # Navigate to URL (aliases: goto, navigate)\nagent-browser click <sel>             # Click element (--new-tab to open in new tab)\nagent-browser dblclick <sel>          # Double-click element\nagent-browser focus <sel>             # Focus element\nagent-browser type <sel> <text>       # Type into element\nagent-browser fill <sel> <text>       # Clear and fill\nagent-browser press <key>             # Press key (Enter, Tab, Control+a) (alias: key)\nagent-browser keyboard type <text>    # Type with real keystrokes (no selector, current focus)\nagent-browser keyboard inserttext <text>  # Insert text without key events (no selector)\nagent-browser keydown <key>           # Hold key down\nagent-browser keyup <key>             # Release key\nagent-browser hover <sel>             # Hover element\nagent-browser select <sel> <val>      # Select dropdown option\nagent-browser check <sel>             # Check checkbox\nagent-browser uncheck <sel>           # Uncheck checkbox\nagent-browser scroll <dir> [px]       # Scroll (up/down/left/right, --selector <sel>)\nagent-browser scrollintoview <sel>    # Scroll element into view (alias: scrollinto)\nagent-browser drag <src> <tgt>        # Drag and drop\nagent-browser upload <sel> <files>    # Upload files\nagent-browser screenshot [path]       # Take screenshot (--full for full page, saves to a temporary directory if no path)\nagent-browser screenshot --annotate   # Annotated screenshot with numbered element labels\nagent-browser pdf <path>              # Save as PDF\nagent-browser snapshot                # Accessibility tree with refs (best for AI)\nagent-browser eval <js>               # Run JavaScript (-b for base64, --stdin for piped input)\nagent-browser connect <port>          # Connect to browser via CDP\nagent-browser close                   # Close browser (aliases: quit, exit)\nGet Info\nagent-browser get text <sel>          # Get text content\nagent-browser get html <sel>          # Get innerHTML\nagent-browser get value <sel>         # Get input value\nagent-browser get attr <sel> <attr>   # Get attribute\nagent-browser get title               # Get page title\nagent-browser get url                 # Get current URL\nagent-browser get count <sel>         # Count matching elements\nagent-browser get box <sel>           # Get bounding box\nagent-browser get styles <sel>        # Get computed styles\nCheck State\nagent-browser is visible <sel>        # Check if visible\nagent-browser is enabled <sel>        # Check if enabled\nagent-browser is checked <sel>        # Check if checked\nFind Elements (Semantic Locators)\nagent-browser find role <role> <action> [value]       # By ARIA role\nagent-browser find text <text> <action>               # By text content\nagent-browser find label <label> <action> [value]     # By label\nagent-browser find placeholder <ph> <action> [value]  # By placeholder\nagent-browser find alt <text> <action>                # By alt text\nagent-browser find title <text> <action>              # By title attr\nagent-browser find testid <id> <action> [value]       # By data-testid\nagent-browser find first <sel> <action> [value]       # First match\nagent-browser find last <sel> <action> [value]        # Last match\nagent-browser find nth <n> <sel> <action> [value]     # Nth match\n\nActions: click, fill, type, hover, focus, check, uncheck, text\n\nOptions: --name <name> (filter role by accessible name), --exact (require exact text match)\n\nExamples:\n\nagent-browser find role button click --name \"Submit\"\nagent-browser find text \"Sign In\" click\nagent-browser find label \"Email\" fill \"test@test.com\"\nagent-browser find first \".item\" click\nagent-browser find nth 2 \"a\" text\nWait\nagent-browser wait <selector>         # Wait for element to be visible\nagent-browser wait <ms>               # Wait for time (milliseconds)\nagent-browser wait --text \"Welcome\"   # Wait for text to appear\nagent-browser wait --url \"**/dash\"    # Wait for URL pattern\nagent-browser wait --load networkidle # Wait for load state\nagent-browser wait --fn \"window.ready === true\"  # Wait for JS condition\n\nLoad states: load, domcontentloaded, networkidle\n\nMouse Control\nagent-browser mouse move <x> <y>      # Move mouse\nagent-browser mouse down [button]     # Press button (left/right/middle)\nagent-browser mouse up [button]       # Release button\nagent-browser mouse wheel <dy> [dx]   # Scroll wheel\nBrowser Settings\nagent-browser set viewport <w> <h>    # Set viewport size\nagent-browser set device <name>       # Emulate device (\"iPhone 14\")\nagent-browser set geo <lat> <lng>     # Set geolocation\nagent-browser set offline [on|off]    # Toggle offline mode\nagent-browser set headers <json>      # Extra HTTP headers\nagent-browser set credentials <u> <p> # HTTP basic auth\nagent-browser set media [dark|light]  # Emulate color scheme\nCookies & Storage\nagent-browser cookies                 # Get all cookies\nagent-browser cookies set <name> <val> # Set cookie\nagent-browser cookies clear           # Clear cookies\n\nagent-browser storage local           # Get all localStorage\nagent-browser storage local <key>     # Get specific key\nagent-browser storage local set <k> <v>  # Set value\nagent-browser storage local clear     # Clear all\n\nagent-browser storage session         # Same for sessionStorage\nNetwork\nagent-browser network route <url>              # Intercept requests\nagent-browser network route <url> --abort      # Block requests\nagent-browser network route <url> --body <json>  # Mock response\nagent-browser network unroute [url]            # Remove routes\nagent-browser network requests                 # View tracked requests\nagent-browser network requests --filter api    # Filter requests\nTabs & Windows\nagent-browser tab                     # List tabs\nagent-browser tab new [url]           # New tab (optionally with URL)\nagent-browser tab <n>                 # Switch to tab n\nagent-browser tab close [n]           # Close tab\nagent-browser window new              # New window\nFrames\nagent-browser frame <sel>             # Switch to iframe\nagent-browser frame main              # Back to main frame\nDialogs\nagent-browser dialog accept [text]    # Accept (with optional prompt text)\nagent-browser dialog dismiss          # Dismiss\nDiff\nagent-browser diff snapshot                              # Compare current vs last snapshot\nagent-browser diff snapshot --baseline before.txt        # Compare current vs saved snapshot file\nagent-browser diff snapshot --selector \"#main\" --compact # Scoped snapshot diff\nagent-browser diff screenshot --baseline before.png      # Visual pixel diff against baseline\nagent-browser diff screenshot --baseline b.png -o d.png  # Save diff image to custom path\nagent-browser diff screenshot --baseline b.png -t 0.2    # Adjust color threshold (0-1)\nagent-browser diff url https://v1.com https://v2.com     # Compare two URLs (snapshot diff)\nagent-browser diff url https://v1.com https://v2.com --screenshot  # Also visual diff\nagent-browser diff url https://v1.com https://v2.com --wait-until networkidle  # Custom wait strategy\nagent-browser diff url https://v1.com https://v2.com --selector \"#main\"  # Scope to element\nDebug\nagent-browser trace start [path]      # Start recording trace\nagent-browser trace stop [path]       # Stop and save trace\nagent-browser profiler start          # Start Chrome DevTools profiling\nagent-browser profiler stop [path]    # Stop and save profile (.json)\nagent-browser console                 # View console messages (log, error, warn, info)\nagent-browser console --clear         # Clear console\nagent-browser errors                  # View page errors (uncaught JavaScript exceptions)\nagent-browser errors --clear          # Clear errors\nagent-browser highlight <sel>         # Highlight element\nagent-browser state save <path>       # Save auth state\nagent-browser state load <path>       # Load auth state\nagent-browser state list              # List saved state files\nagent-browser state show <file>       # Show state summary\nagent-browser state rename <old> <new> # Rename state file\nagent-browser state clear [name]      # Clear states for session\nagent-browser state clear --all       # Clear all saved states\nagent-browser state clean --older-than <days>  # Delete old states\nNavigation\nagent-browser back                    # Go back\nagent-browser forward                 # Go forward\nagent-browser reload                  # Reload page\nSetup\nagent-browser install                 # Download Chromium browser\nagent-browser install --with-deps     # Also install system deps (Linux)\nSessions\n\nRun multiple isolated browser instances:\n\n# Different sessions\nagent-browser --session agent1 open site-a.com\nagent-browser --session agent2 open site-b.com\n\n# Or via environment variable\nAGENT_BROWSER_SESSION=agent1 agent-browser click \"#btn\"\n\n# List active sessions\nagent-browser session list\n# Output:\n# Active sessions:\n# -> default\n#    agent1\n\n# Show current session\nagent-browser session\n\nEach session has its own:\n\nBrowser instance\nCookies and storage\nNavigation history\nAuthentication state\nPersistent Profiles\n\nBy default, browser state (cookies, localStorage, login sessions) is ephemeral and lost when the browser closes. Use --profile to persist state across browser restarts:\n\n# Use a persistent profile directory\nagent-browser --profile ~/.myapp-profile open myapp.com\n\n# Login once, then reuse the authenticated session\nagent-browser --profile ~/.myapp-profile open myapp.com/dashboard\n\n# Or via environment variable\nAGENT_BROWSER_PROFILE=~/.myapp-profile agent-browser open myapp.com\n\nThe profile directory stores:\n\nCookies and localStorage\nIndexedDB data\nService workers\nBrowser cache\nLogin sessions\n\nTip: Use different profile paths for different projects to keep their browser state isolated.\n\nSession Persistence\n\nAlternatively, use --session-name to automatically save and restore cookies and localStorage across browser restarts:\n\n# Auto-save/load state for \"twitter\" session\nagent-browser --session-name twitter open twitter.com\n\n# Login once, then state persists automatically\n# State files stored in ~/.agent-browser/sessions/\n\n# Or via environment variable\nexport AGENT_BROWSER_SESSION_NAME=twitter\nagent-browser open twitter.com\nState Encryption\n\nEncrypt saved session data at rest with AES-256-GCM:\n\n# Generate key: openssl rand -hex 32\nexport AGENT_BROWSER_ENCRYPTION_KEY=<64-char-hex-key>\n\n# State files are now encrypted automatically\nagent-browser --session-name secure open example.com\nVariable\tDescription\nAGENT_BROWSER_SESSION_NAME\tAuto-save/load state persistence name\nAGENT_BROWSER_ENCRYPTION_KEY\t64-char hex key for AES-256-GCM encryption\nAGENT_BROWSER_STATE_EXPIRE_DAYS\tAuto-delete states older than N days (default: 30)\nSecurity\n\nagent-browser includes security features for safe AI agent deployments. All features are opt-in -- existing workflows are unaffected until you explicitly enable a feature:\n\nAuthentication Vault -- Store credentials locally (always encrypted), reference by name. The LLM never sees passwords. A key is auto-generated at ~/.agent-browser/.encryption-key if AGENT_BROWSER_ENCRYPTION_KEY is not set: echo \"pass\" | agent-browser auth save github --url https://github.com/login --username user --password-stdin then agent-browser auth login github\nContent Boundary Markers -- Wrap page output in delimiters so LLMs can distinguish tool output from untrusted content: --content-boundaries\nDomain Allowlist -- Restrict navigation to trusted domains (wildcards like *.example.com also match the bare domain): --allowed-domains \"example.com,*.example.com\". Sub-resource requests (scripts, images, fetch) and WebSocket/EventSource connections to non-allowed domains are also blocked. Include any CDN domains your target pages depend on (e.g., *.cdn.example.com).\nAction Policy -- Gate destructive actions with a static policy file: --action-policy ./policy.json\nAction Confirmation -- Require explicit approval for sensitive action categories: --confirm-actions eval,download\nOutput Length Limits -- Prevent context flooding: --max-output 50000\nVariable\tDescription\nAGENT_BROWSER_CONTENT_BOUNDARIES\tWrap page output in boundary markers\nAGENT_BROWSER_MAX_OUTPUT\tMax characters for page output\nAGENT_BROWSER_ALLOWED_DOMAINS\tComma-separated allowed domain patterns\nAGENT_BROWSER_ACTION_POLICY\tPath to action policy JSON file\nAGENT_BROWSER_CONFIRM_ACTIONS\tAction categories requiring confirmation\nAGENT_BROWSER_CONFIRM_INTERACTIVE\tEnable interactive confirmation prompts\n\nSee Security documentation for details.\n\nSnapshot Options\n\nThe snapshot command supports filtering to reduce output size:\n\nagent-browser snapshot                    # Full accessibility tree\nagent-browser snapshot -i                 # Interactive elements only (buttons, inputs, links)\nagent-browser snapshot -i -C              # Include cursor-interactive elements (divs with onclick, etc.)\nagent-browser snapshot -c                 # Compact (remove empty structural elements)\nagent-browser snapshot -d 3               # Limit depth to 3 levels\nagent-browser snapshot -s \"#main\"         # Scope to CSS selector\nagent-browser snapshot -i -c -d 5         # Combine options\nOption\tDescription\n-i, --interactive\tOnly show interactive elements (buttons, links, inputs)\n-C, --cursor\tInclude cursor-interactive elements (cursor:pointer, onclick, tabindex)\n-c, --compact\tRemove empty structural elements\n-d, --depth <n>\tLimit tree depth\n-s, --selector <sel>\tScope to CSS selector\n\nThe -C flag is useful for modern web apps that use custom clickable elements (divs, spans) instead of standard buttons/links.\n\nAnnotated Screenshots\n\nThe --annotate flag overlays numbered labels on interactive elements in the screenshot. Each label [N] corresponds to ref @eN, so the same refs work for both visual and text-based workflows.\n\nagent-browser screenshot --annotate\n# -> Screenshot saved to /tmp/screenshot-2026-02-17T12-00-00-abc123.png\n#    [1] @e1 button \"Submit\"\n#    [2] @e2 link \"Home\"\n#    [3] @e3 textbox \"Email\"\n\nAfter an annotated screenshot, refs are cached so you can immediately interact with elements:\n\nagent-browser screenshot --annotate ./page.png\nagent-browser click @e2     # Click the \"Home\" link labeled [2]\n\nThis is useful for multimodal AI models that can reason about visual layout, unlabeled icon buttons, canvas elements, or visual state that the text accessibility tree cannot capture.\n\nOptions\nOption\tDescription\n--session <name>\tUse isolated session (or AGENT_BROWSER_SESSION env)\n--session-name <name>\tAuto-save/restore session state (or AGENT_BROWSER_SESSION_NAME env)\n--profile <path>\tPersistent browser profile directory (or AGENT_BROWSER_PROFILE env)\n--state <path>\tLoad storage state from JSON file (or AGENT_BROWSER_STATE env)\n--headers <json>\tSet HTTP headers scoped to the URL's origin\n--executable-path <path>\tCustom browser executable (or AGENT_BROWSER_EXECUTABLE_PATH env)\n--extension <path>\tLoad browser extension (repeatable; or AGENT_BROWSER_EXTENSIONS env)\n--args <args>\tBrowser launch args, comma or newline separated (or AGENT_BROWSER_ARGS env)\n--user-agent <ua>\tCustom User-Agent string (or AGENT_BROWSER_USER_AGENT env)\n--proxy <url>\tProxy server URL with optional auth (or AGENT_BROWSER_PROXY env)\n--proxy-bypass <hosts>\tHosts to bypass proxy (or AGENT_BROWSER_PROXY_BYPASS env)\n--ignore-https-errors\tIgnore HTTPS certificate errors (useful for self-signed certs)\n--allow-file-access\tAllow file:// URLs to access local files (Chromium only)\n-p, --provider <name>\tCloud browser provider (or AGENT_BROWSER_PROVIDER env)\n--device <name>\tiOS device name, e.g. \"iPhone 15 Pro\" (or AGENT_BROWSER_IOS_DEVICE env)\n--json\tJSON output (for agents)\n--full, -f\tFull page screenshot\n--annotate\tAnnotated screenshot with numbered element labels (or AGENT_BROWSER_ANNOTATE env)\n--headed\tShow browser window (not headless)\n--cdp <port|url>\tConnect via Chrome DevTools Protocol (port or WebSocket URL)\n--auto-connect\tAuto-discover and connect to running Chrome (or AGENT_BROWSER_AUTO_CONNECT env)\n--color-scheme <scheme>\tColor scheme: dark, light, no-preference (or AGENT_BROWSER_COLOR_SCHEME env)\n--download-path <path>\tDefault download directory (or AGENT_BROWSER_DOWNLOAD_PATH env)\n--content-boundaries\tWrap page output in boundary markers for LLM safety (or AGENT_BROWSER_CONTENT_BOUNDARIES env)\n--max-output <chars>\tTruncate page output to N characters (or AGENT_BROWSER_MAX_OUTPUT env)\n--allowed-domains <list>\tComma-separated allowed domain patterns (or AGENT_BROWSER_ALLOWED_DOMAINS env)\n--action-policy <path>\tPath to action policy JSON file (or AGENT_BROWSER_ACTION_POLICY env)\n--confirm-actions <list>\tAction categories requiring confirmation (or AGENT_BROWSER_CONFIRM_ACTIONS env)\n--confirm-interactive\tInteractive confirmation prompts; auto-denies if stdin is not a TTY (or AGENT_BROWSER_CONFIRM_INTERACTIVE env)\n--config <path>\tUse a custom config file (or AGENT_BROWSER_CONFIG env)\n--debug\tDebug output\nConfiguration\n\nCreate an agent-browser.json file to set persistent defaults instead of repeating flags on every command.\n\nLocations (lowest to highest priority):\n\n~/.agent-browser/config.json -- user-level defaults\n./agent-browser.json -- project-level overrides (in working directory)\nAGENT_BROWSER_* environment variables override config file values\nCLI flags override everything\n\nExample agent-browser.json:\n\n{\n  \"headed\": true,\n  \"proxy\": \"http://localhost:8080\",\n  \"profile\": \"./browser-data\",\n  \"userAgent\": \"my-agent/1.0\",\n  \"ignoreHttpsErrors\": true\n}\n\nUse --config <path> or AGENT_BROWSER_CONFIG to load a specific config file instead of the defaults:\n\nagent-browser --config ./ci-config.json open example.com\nAGENT_BROWSER_CONFIG=./ci-config.json agent-browser open example.com\n\nAll options from the table above can be set in the config file using camelCase keys (e.g., --executable-path becomes \"executablePath\", --proxy-bypass becomes \"proxyBypass\"). Unknown keys are ignored for forward compatibility.\n\nBoolean flags accept an optional true/false value to override config settings. For example, --headed false disables \"headed\": true from config. A bare --headed is equivalent to --headed true.\n\nAuto-discovered config files that are missing are silently ignored. If --config <path> points to a missing or invalid file, agent-browser exits with an error. Extensions from user and project configs are merged (concatenated), not replaced.\n\nTip: If your project-level agent-browser.json contains environment-specific values (paths, proxies), consider adding it to .gitignore.\n\nDefault Timeout\n\nThe default Playwright timeout for standard operations (clicks, waits, fills, etc.) is 25 seconds. This is intentionally below the CLI's 30-second IPC read timeout so that Playwright returns a proper error instead of the CLI timing out with EAGAIN.\n\nOverride the default timeout via environment variable:\n\n# Set a longer timeout for slow pages (in milliseconds)\nexport AGENT_BROWSER_DEFAULT_TIMEOUT=45000\n\nNote: Setting this above 30000 (30s) may cause EAGAIN errors on slow operations because the CLI's read timeout will expire before Playwright responds. The CLI retries transient errors automatically, but response times will increase.\n\nVariable\tDescription\nAGENT_BROWSER_DEFAULT_TIMEOUT\tDefault Playwright timeout in ms (default: 25000)\nSelectors\nRefs (Recommended for AI)\n\nRefs provide deterministic element selection from snapshots:\n\n# 1. Get snapshot with refs\nagent-browser snapshot\n# Output:\n# - heading \"Example Domain\" [ref=e1] [level=1]\n# - button \"Submit\" [ref=e2]\n# - textbox \"Email\" [ref=e3]\n# - link \"Learn more\" [ref=e4]\n\n# 2. Use refs to interact\nagent-browser click @e2                   # Click the button\nagent-browser fill @e3 \"test@example.com\" # Fill the textbox\nagent-browser get text @e1                # Get heading text\nagent-browser hover @e4                   # Hover the link\n\nWhy use refs?\n\nDeterministic: Ref points to exact element from snapshot\nFast: No DOM re-query needed\nAI-friendly: Snapshot + ref workflow is optimal for LLMs\nCSS Selectors\nagent-browser click \"#id\"\nagent-browser click \".class\"\nagent-browser click \"div > button\"\nText & XPath\nagent-browser click \"text=Submit\"\nagent-browser click \"xpath=//button\"\nSemantic Locators\nagent-browser find role button click --name \"Submit\"\nagent-browser find label \"Email\" fill \"test@test.com\"\nAgent Mode\n\nUse --json for machine-readable output:\n\nagent-browser snapshot --json\n# Returns: {\"success\":true,\"data\":{\"snapshot\":\"...\",\"refs\":{\"e1\":{\"role\":\"heading\",\"name\":\"Title\"},...}}}\n\nagent-browser get text @e1 --json\nagent-browser is visible @e2 --json\nOptimal AI Workflow\n# 1. Navigate and get snapshot\nagent-browser open example.com\nagent-browser snapshot -i --json   # AI parses tree and refs\n\n# 2. AI identifies target refs from snapshot\n# 3. Execute actions using refs\nagent-browser click @e2\nagent-browser fill @e3 \"input text\"\n\n# 4. Get new snapshot if page changed\nagent-browser snapshot -i --json\nCommand Chaining\n\nCommands can be chained with && in a single shell invocation. The browser persists via a background daemon, so chaining is safe and more efficient:\n\n# Open, wait for load, and snapshot in one call\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser snapshot -i\n\n# Chain multiple interactions\nagent-browser fill @e1 \"user@example.com\" && agent-browser fill @e2 \"pass\" && agent-browser click @e3\n\n# Navigate and screenshot\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser screenshot page.png\n\nUse && when you don't need intermediate output. Run commands separately when you need to parse output first (e.g., snapshot to discover refs before interacting).\n\nHeaded Mode\n\nShow the browser window for debugging:\n\nagent-browser open example.com --headed\n\nThis opens a visible browser window instead of running headless.\n\nAuthenticated Sessions\n\nUse --headers to set HTTP headers for a specific origin, enabling authentication without login flows:\n\n# Headers are scoped to api.example.com only\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer <token>\"}'\n\n# Requests to api.example.com include the auth header\nagent-browser snapshot -i --json\nagent-browser click @e2\n\n# Navigate to another domain - headers are NOT sent (safe!)\nagent-browser open other-site.com\n\nThis is useful for:\n\nSkipping login flows - Authenticate via headers instead of UI\nSwitching users - Start new sessions with different auth tokens\nAPI testing - Access protected endpoints directly\nSecurity - Headers are scoped to the origin, not leaked to other domains\n\nTo set headers for multiple origins, use --headers with each open command:\n\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer token1\"}'\nagent-browser open api.acme.com --headers '{\"Authorization\": \"Bearer token2\"}'\n\nFor global headers (all domains), use set headers:\n\nagent-browser set headers '{\"X-Custom-Header\": \"value\"}'\nCustom Browser Executable\n\nUse a custom browser executable instead of the bundled Chromium. This is useful for:\n\nServerless deployment: Use lightweight Chromium builds like @sparticuz/chromium (~50MB vs ~684MB)\nSystem browsers: Use an existing Chrome/Chromium installation\nCustom builds: Use modified browser builds\nCLI Usage\n# Via flag\nagent-browser --executable-path /path/to/chromium open example.com\n\n# Via environment variable\nAGENT_BROWSER_EXECUTABLE_PATH=/path/to/chromium agent-browser open example.com\nServerless Example (Vercel/AWS Lambda)\nimport chromium from '@sparticuz/chromium';\nimport { BrowserManager } from 'agent-browser';\n\nexport async function handler() {\n  const browser = new BrowserManager();\n  await browser.launch({\n    executablePath: await chromium.executablePath(),\n    headless: true,\n  });\n  // ... use browser\n}\nLocal Files\n\nOpen and interact with local files (PDFs, HTML, etc.) using file:// URLs:\n\n# Enable file access (required for JavaScript to access local files)\nagent-browser --allow-file-access open file:///path/to/document.pdf\nagent-browser --allow-file-access open file:///path/to/page.html\n\n# Take screenshot of a local PDF\nagent-browser --allow-file-access open file:///Users/me/report.pdf\nagent-browser screenshot report.png\n\nThe --allow-file-access flag adds Chromium flags (--allow-file-access-from-files, --allow-file-access) that allow file:// URLs to:\n\nLoad and render local files\nAccess other local files via JavaScript (XHR, fetch)\nLoad local resources (images, scripts, stylesheets)\n\nNote: This flag only works with Chromium. For security, it's disabled by default.\n\nCDP Mode\n\nConnect to an existing browser via Chrome DevTools Protocol:\n\n# Start Chrome with: google-chrome --remote-debugging-port=9222\n\n# Connect once, then run commands without --cdp\nagent-browser connect 9222\nagent-browser snapshot\nagent-browser tab\nagent-browser close\n\n# Or pass --cdp on each command\nagent-browser --cdp 9222 snapshot\n\n# Connect to remote browser via WebSocket URL\nagent-browser --cdp \"wss://your-browser-service.com/cdp?token=...\" snapshot\n\nThe --cdp flag accepts either:\n\nA port number (e.g., 9222) for local connections via http://localhost:{port}\nA full WebSocket URL (e.g., wss://... or ws://...) for remote browser services\n\nThis enables control of:\n\nElectron apps\nChrome/Chromium instances with remote debugging\nWebView2 applications\nAny browser exposing a CDP endpoint\nAuto-Connect\n\nUse --auto-connect to automatically discover and connect to a running Chrome instance without specifying a port:\n\n# Auto-discover running Chrome with remote debugging\nagent-browser --auto-connect open example.com\nagent-browser --auto-connect snapshot\n\n# Or via environment variable\nAGENT_BROWSER_AUTO_CONNECT=1 agent-browser snapshot\n\nAuto-connect discovers Chrome by:\n\nReading Chrome's DevToolsActivePort file from the default user data directory\nFalling back to probing common debugging ports (9222, 9229)\n\nThis is useful when:\n\nChrome 144+ has remote debugging enabled via chrome://inspect/#remote-debugging (which uses a dynamic port)\nYou want a zero-configuration connection to your existing browser\nYou don't want to track which port Chrome is using\nStreaming (Browser Preview)\n\nStream the browser viewport via WebSocket for live preview or \"pair browsing\" where a human can watch and interact alongside an AI agent.\n\nEnable Streaming\n\nSet the AGENT_BROWSER_STREAM_PORT environment variable:\n\nAGENT_BROWSER_STREAM_PORT=9223 agent-browser open example.com\n\nThis starts a WebSocket server on the specified port that streams the browser viewport and accepts input events.\n\nWebSocket Protocol\n\nConnect to ws://localhost:9223 to receive frames and send input:\n\nReceive frames:\n\n{\n  \"type\": \"frame\",\n  \"data\": \"<base64-encoded-jpeg>\",\n  \"metadata\": {\n    \"deviceWidth\": 1280,\n    \"deviceHeight\": 720,\n    \"pageScaleFactor\": 1,\n    \"offsetTop\": 0,\n    \"scrollOffsetX\": 0,\n    \"scrollOffsetY\": 0\n  }\n}\n\nSend mouse events:\n\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mousePressed\",\n  \"x\": 100,\n  \"y\": 200,\n  \"button\": \"left\",\n  \"clickCount\": 1\n}\n\nSend keyboard events:\n\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"keyDown\",\n  \"key\": \"Enter\",\n  \"code\": \"Enter\"\n}\n\nSend touch events:\n\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchStart\",\n  \"touchPoints\": [{ \"x\": 100, \"y\": 200 }]\n}\nProgrammatic API\n\nFor advanced use, control streaming directly via the protocol:\n\nimport { BrowserManager } from 'agent-browser';\n\nconst browser = new BrowserManager();\nawait browser.launch({ headless: true });\nawait browser.navigate('https://example.com');\n\n// Start screencast\nawait browser.startScreencast((frame) => {\n  // frame.data is base64-encoded image\n  // frame.metadata contains viewport info\n  console.log('Frame received:', frame.metadata.deviceWidth, 'x', frame.metadata.deviceHeight);\n}, {\n  format: 'jpeg',\n  quality: 80,\n  maxWidth: 1280,\n  maxHeight: 720,\n});\n\n// Inject mouse events\nawait browser.injectMouseEvent({\n  type: 'mousePressed',\n  x: 100,\n  y: 200,\n  button: 'left',\n});\n\n// Inject keyboard events\nawait browser.injectKeyboardEvent({\n  type: 'keyDown',\n  key: 'Enter',\n  code: 'Enter',\n});\n\n// Stop when done\nawait browser.stopScreencast();\nArchitecture\n\nagent-browser uses a client-daemon architecture:\n\nRust CLI (fast native binary) - Parses commands, communicates with daemon\nNode.js Daemon - Manages Playwright browser instance\nFallback - If native binary unavailable, uses Node.js directly\n\nThe daemon starts automatically on first command and persists between commands for fast subsequent operations.\n\nBrowser Engine: Uses Chromium by default. The daemon also supports Firefox and WebKit via the Playwright protocol.\n\nPlatforms\nPlatform\tBinary\tFallback\nmacOS ARM64\tNative Rust\tNode.js\nmacOS x64\tNative Rust\tNode.js\nLinux ARM64\tNative Rust\tNode.js\nLinux x64\tNative Rust\tNode.js\nWindows x64\tNative Rust\tNode.js\nUsage with AI Agents\nJust ask the agent\n\nThe simplest approach -- just tell your agent to use it:\n\nUse agent-browser to test the login flow. Run agent-browser --help to see available commands.\n\n\nThe --help output is comprehensive and most agents can figure it out from there.\n\nAI Coding Assistants (recommended)\n\nAdd the skill to your AI coding assistant for richer context:\n\nnpx skills add vercel-labs/agent-browser\n\nThis works with Claude Code, Codex, Cursor, Gemini CLI, GitHub Copilot, Goose, OpenCode, and Windsurf. The skill is fetched from the repository, so it stays up to date automatically -- do not copy SKILL.md from node_modules as it will become stale.\n\nClaude Code\n\nInstall as a Claude Code skill:\n\nnpx skills add vercel-labs/agent-browser\n\nThis adds the skill to .claude/skills/agent-browser/SKILL.md in your project. The skill teaches Claude Code the full agent-browser workflow, including the snapshot-ref interaction pattern, session management, and timeout handling.\n\nAGENTS.md / CLAUDE.md\n\nFor more consistent results, add to your project or global instructions file:\n\n## Browser Automation\n\nUse `agent-browser` for web automation. Run `agent-browser --help` for all commands.\n\nCore workflow:\n1. `agent-browser open <url>` - Navigate to page\n2. `agent-browser snapshot -i` - Get interactive elements with refs (@e1, @e2)\n3. `agent-browser click @e1` / `fill @e2 \"text\"` - Interact using refs\n4. Re-snapshot after page changes\nIntegrations\niOS Simulator\n\nControl real Mobile Safari in the iOS Simulator for authentic mobile web testing. Requires macOS with Xcode.\n\nSetup:\n\n# Install Appium and XCUITest driver\nnpm install -g appium\nappium driver install xcuitest\n\nUsage:\n\n# List available iOS simulators\nagent-browser device list\n\n# Launch Safari on a specific device\nagent-browser -p ios --device \"iPhone 16 Pro\" open https://example.com\n\n# Same commands as desktop\nagent-browser -p ios snapshot -i\nagent-browser -p ios tap @e1\nagent-browser -p ios fill @e2 \"text\"\nagent-browser -p ios screenshot mobile.png\n\n# Mobile-specific commands\nagent-browser -p ios swipe up\nagent-browser -p ios swipe down 500\n\n# Close session\nagent-browser -p ios close\n\nOr use environment variables:\n\nexport AGENT_BROWSER_PROVIDER=ios\nexport AGENT_BROWSER_IOS_DEVICE=\"iPhone 16 Pro\"\nagent-browser open https://example.com\nVariable\tDescription\nAGENT_BROWSER_PROVIDER\tSet to ios to enable iOS mode\nAGENT_BROWSER_IOS_DEVICE\tDevice name (e.g., \"iPhone 16 Pro\", \"iPad Pro\")\nAGENT_BROWSER_IOS_UDID\tDevice UDID (alternative to device name)\n\nSupported devices: All iOS Simulators available in Xcode (iPhones, iPads), plus real iOS devices.\n\nNote: The iOS provider boots the simulator, starts Appium, and controls Safari. First launch takes ~30-60 seconds; subsequent commands are fast.\n\nReal Device Support\n\nAppium also supports real iOS devices connected via USB. This requires additional one-time setup:\n\n1. Get your device UDID:\n\nxcrun xctrace list devices\n# or\nsystem_profiler SPUSBDataType | grep -A 5 \"iPhone\\|iPad\"\n\n2. Sign WebDriverAgent (one-time):\n\n# Open the WebDriverAgent Xcode project\ncd ~/.appium/node_modules/appium-xcuitest-driver/node_modules/appium-webdriveragent\nopen WebDriverAgent.xcodeproj\n\nIn Xcode:\n\nSelect the WebDriverAgentRunner target\nGo to Signing & Capabilities\nSelect your Team (requires Apple Developer account, free tier works)\nLet Xcode manage signing automatically\n\n3. Use with agent-browser:\n\n# Connect device via USB, then:\nagent-browser -p ios --device \"<DEVICE_UDID>\" open https://example.com\n\n# Or use the device name if unique\nagent-browser -p ios --device \"John's iPhone\" open https://example.com\n\nReal device notes:\n\nFirst run installs WebDriverAgent to the device (may require Trust prompt)\nDevice must be unlocked and connected via USB\nSlightly slower initial connection than simulator\nTests against real Safari performance and behavior\nBrowserbase\n\nBrowserbase provides remote browser infrastructure to make deployment of agentic browsing agents easy. Use it when running the agent-browser CLI in an environment where a local browser isn't feasible.\n\nTo enable Browserbase, use the -p flag:\n\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser -p browserbase open https://example.com\n\nOr use environment variables for CI/scripts:\n\nexport AGENT_BROWSER_PROVIDER=browserbase\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser open https://example.com\n\nWhen enabled, agent-browser connects to a Browserbase session instead of launching a local browser. All commands work identically.\n\nGet your API key and project ID from the Browserbase Dashboard.\n\nBrowser Use\n\nBrowser Use provides cloud browser infrastructure for AI agents. Use it when running agent-browser in environments where a local browser isn't available (serverless, CI/CD, etc.).\n\nTo enable Browser Use, use the -p flag:\n\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser -p browseruse open https://example.com\n\nOr use environment variables for CI/scripts:\n\nexport AGENT_BROWSER_PROVIDER=browseruse\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser open https://example.com\n\nWhen enabled, agent-browser connects to a Browser Use cloud session instead of launching a local browser. All commands work identically.\n\nGet your API key from the Browser Use Cloud Dashboard. Free credits are available to get started, with pay-as-you-go pricing after.\n\nKernel\n\nKernel provides cloud browser infrastructure for AI agents with features like stealth mode and persistent profiles.\n\nTo enable Kernel, use the -p flag:\n\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser -p kernel open https://example.com\n\nOr use environment variables for CI/scripts:\n\nexport AGENT_BROWSER_PROVIDER=kernel\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser open https://example.com\n\nOptional configuration via environment variables:\n\nVariable\tDescription\tDefault\nKERNEL_HEADLESS\tRun browser in headless mode (true/false)\tfalse\nKERNEL_STEALTH\tEnable stealth mode to avoid bot detection (true/false)\ttrue\nKERNEL_TIMEOUT_SECONDS\tSession timeout in seconds\t300\nKERNEL_PROFILE_NAME\tBrowser profile name for persistent cookies/logins (created if it doesn't exist)\t(none)\n\nWhen enabled, agent-browser connects to a Kernel cloud session instead of launching a local browser. All commands work identically.\n\nProfile Persistence: When KERNEL_PROFILE_NAME is set, the profile will be created if it doesn't already exist. Cookies, logins, and session data are automatically saved back to the profile when the browser session ends, making them available for future sessions.\n\nGet your API key from the Kernel Dashboard.\n\nLicense\n\nApache-2.0",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006899,
    "timestamp": "2026-02-26T22:35:47.599Z",
    "title": "Quick Start | agent-browser",
    "url": "https://agent-browser.dev/quick-start",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nQuick Start\nCORE WORKFLOW\n\nEvery browser automation follows this pattern:\n\n# 1. Navigate\nagent-browser open example.com\n\n# 2. Snapshot to get element refs\nagent-browser snapshot -i\n# Output:\n# @e1 [heading] \"Example Domain\"\n# @e2 [link] \"More information...\"\n\n# 3. Interact using refs\nagent-browser click @e2\n\n# 4. Re-snapshot after page changes\nagent-browser snapshot -i\nCOMMON COMMANDS\nagent-browser open example.com\nagent-browser snapshot -i                # Get interactive elements with refs\nagent-browser click @e2                  # Click by ref\nagent-browser fill @e3 \"test@example.com\" # Fill input by ref\nagent-browser get text @e1               # Get text content\nagent-browser screenshot                 # Save to temp directory\nagent-browser screenshot page.png        # Save to specific path\nagent-browser close\nTRADITIONAL SELECTORS\n\nCSS selectors and semantic locators also supported:\n\nagent-browser click \"#submit\"\nagent-browser fill \"#email\" \"test@example.com\"\nagent-browser find role button click --name \"Submit\"\nHEADED MODE\n\nShow browser window for debugging:\n\nagent-browser open example.com --headed\nWAIT FOR CONTENT\nagent-browser wait @e1                   # Wait for element\nagent-browser wait --load networkidle    # Wait for network idle\nagent-browser wait --url \"**/dashboard\"  # Wait for URL pattern\nagent-browser wait 2000                  # Wait milliseconds\nCOMMAND CHAINING\n\nChain commands with && in a single shell call. The browser persists via a background daemon, so chaining is safe and efficient:\n\n# Open, wait, and snapshot in one call\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser snapshot -i\n\n# Chain multiple interactions\nagent-browser fill @e1 \"user@example.com\" && agent-browser fill @e2 \"pass\" && agent-browser click @e3\n\n# Navigate and capture\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser screenshot page.png\n\nUse && when you don't need intermediate output. Run commands separately when you need to parse output first (e.g., snapshot to discover refs before interacting).\n\nJSON OUTPUT\n\nFor programmatic parsing in scripts:\n\nagent-browser snapshot --json\nagent-browser get text @e1 --json\n\nNote: The default text output is more compact and preferred for AI agents.\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006902,
    "timestamp": "2026-02-26T22:35:47.600Z",
    "title": "Commands | agent-browser",
    "url": "https://agent-browser.dev/commands",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nCommands\nCORE\nagent-browser open <url>              # Navigate (aliases: goto, navigate)\nagent-browser click <sel>             # Click element (--new-tab to open in new tab)\nagent-browser dblclick <sel>          # Double-click\nagent-browser fill <sel> <text>       # Clear and fill\nagent-browser type <sel> <text>       # Type into element\nagent-browser press <key>             # Press key (Enter, Tab, Control+a) (alias: key)\nagent-browser keyboard type <text>    # Type at current focus (no selector needed)\nagent-browser keyboard inserttext <text>  # Insert text without key events\nagent-browser keydown <key>           # Hold key down\nagent-browser keyup <key>             # Release key\nagent-browser hover <sel>             # Hover element\nagent-browser focus <sel>             # Focus element\nagent-browser select <sel> <val>      # Select dropdown option\nagent-browser check <sel>             # Check checkbox\nagent-browser uncheck <sel>           # Uncheck checkbox\nagent-browser scroll <dir> [px]       # Scroll (up/down/left/right, --selector <sel>)\nagent-browser scrollintoview <sel>    # Scroll element into view\nagent-browser drag <src> <dst>        # Drag and drop\nagent-browser upload <sel> <files>    # Upload files\nagent-browser screenshot [path]       # Screenshot (--full for full page)\nagent-browser screenshot --annotate   # Annotated screenshot with numbered element labels\nagent-browser pdf <path>              # Save page as PDF\nagent-browser snapshot                # Accessibility tree with refs\nagent-browser eval <js>               # Run JavaScript\nagent-browser connect <port|url>      # Connect to browser via CDP\nagent-browser close                   # Close browser (aliases: quit, exit)\nGET INFO\nagent-browser get text <sel>          # Get text content\nagent-browser get html <sel>          # Get innerHTML\nagent-browser get value <sel>         # Get input value\nagent-browser get attr <sel> <attr>   # Get attribute\nagent-browser get title               # Get page title\nagent-browser get url                 # Get current URL\nagent-browser get count <sel>         # Count matching elements\nagent-browser get box <sel>           # Get bounding box\nagent-browser get styles <sel>        # Get computed styles\nCHECK STATE\nagent-browser is visible <sel>        # Check if visible\nagent-browser is enabled <sel>        # Check if enabled\nagent-browser is checked <sel>        # Check if checked\nFIND ELEMENTS\n\nSemantic locators with actions (click, fill, type, hover, focus, check, uncheck, text):\n\nagent-browser find role <role> <action> [value]\nagent-browser find text <text> <action>\nagent-browser find label <label> <action> [value]\nagent-browser find placeholder <ph> <action> [value]\nagent-browser find alt <text> <action>\nagent-browser find title <text> <action>\nagent-browser find testid <id> <action> [value]\nagent-browser find first <sel> <action> [value]\nagent-browser find last <sel> <action> [value]\nagent-browser find nth <n> <sel> <action> [value]\n\nOptions:\n\n--name <name> -- filter role by accessible name\n--exact -- require exact text match\n\nExamples:\n\nagent-browser find role button click --name \"Submit\"\nagent-browser find label \"Email\" fill \"test@test.com\"\nagent-browser find alt \"Logo\" click\nagent-browser find first \".item\" click\nagent-browser find last \".item\" text\nagent-browser find nth 2 \".card\" hover\nWAIT\nagent-browser wait <selector>         # Wait for element\nagent-browser wait <ms>               # Wait for time\nagent-browser wait --text \"Welcome\"   # Wait for text\nagent-browser wait --url \"**/dash\"    # Wait for URL pattern\nagent-browser wait --load networkidle # Wait for load state\nagent-browser wait --fn \"condition\"   # Wait for JS condition\nagent-browser wait --download [path]  # Wait for download\nDOWNLOADS\nagent-browser download <sel> <path>   # Click element to trigger download\nagent-browser wait --download [path]  # Wait for any download to complete\n\nUse --download-path <dir> (or AGENT_BROWSER_DOWNLOAD_PATH env) to set a default download directory. Without it, downloads go to a temporary directory that is deleted when the browser closes.\n\nMOUSE\nagent-browser mouse move <x> <y>      # Move mouse\nagent-browser mouse down [button]     # Press button\nagent-browser mouse up [button]       # Release button\nagent-browser mouse wheel <dy> [dx]   # Scroll wheel\nSETTINGS\nagent-browser set viewport <w> <h>    # Set viewport size\nagent-browser set device <name>       # Emulate device (\"iPhone 14\")\nagent-browser set geo <lat> <lng>     # Set geolocation\nagent-browser set offline [on|off]    # Toggle offline mode\nagent-browser set headers <json>      # Extra HTTP headers\nagent-browser set credentials <u> <p> # HTTP basic auth\nagent-browser set media [dark|light]  # Emulate color scheme (persists for session)\n\nUse --color-scheme for persistent dark/light mode across all commands:\n\nagent-browser --color-scheme dark open https://example.com\nCOOKIES & STORAGE\nagent-browser cookies                 # Get all cookies\nagent-browser cookies set <name> <val> # Set cookie\nagent-browser cookies clear           # Clear cookies\n\nagent-browser storage local           # Get all localStorage\nagent-browser storage local <key>     # Get specific key\nagent-browser storage local set <k> <v>  # Set value\nagent-browser storage local clear     # Clear all\n\nagent-browser storage session         # Same for sessionStorage\nNETWORK\nagent-browser network route <url>              # Intercept requests\nagent-browser network route <url> --abort      # Block requests\nagent-browser network route <url> --body <json>  # Mock response\nagent-browser network unroute [url]            # Remove routes\nagent-browser network requests                 # View tracked requests\nagent-browser network requests --clear         # Clear request log\nagent-browser network requests --filter <pat>  # Filter by URL pattern\nTABS & FRAMES\nagent-browser tab                     # List tabs\nagent-browser tab new [url]           # New tab\nagent-browser tab <n>                 # Switch to tab\nagent-browser tab close [n]           # Close tab\nagent-browser window new              # Open new browser window\nagent-browser frame <sel>             # Switch to iframe\nagent-browser frame main              # Back to main frame\nDIALOGS\nagent-browser dialog accept [text]    # Accept dialog (with optional prompt text)\nagent-browser dialog dismiss          # Dismiss dialog\nDEBUG\nagent-browser trace start [path]      # Start trace\nagent-browser trace stop [path]       # Stop and save trace\nagent-browser profiler start          # Start Chrome DevTools profiling\nagent-browser profiler stop [path]    # Stop and save profile (.json)\nagent-browser record start <path>     # Start video recording (WebM)\nagent-browser record stop             # Stop and save video\nagent-browser record restart <path>   # Stop current and start new recording\nagent-browser console                 # View console messages\nagent-browser console --clear         # Clear console log\nagent-browser errors                  # View page errors\nagent-browser errors --clear          # Clear error log\nagent-browser highlight <sel>         # Highlight element\nAUTH VAULT\nagent-browser auth save <name> [opts]    # Save auth profile\nagent-browser auth login <name>          # Login using saved credentials\nagent-browser auth list                  # List saved profiles (names and URLs only)\nagent-browser auth show <name>           # Show profile metadata (no passwords)\nagent-browser auth delete <name>         # Delete a saved profile\n\nSave options:\n\n--url <url> -- login page URL (required)\n--username <user> -- username (required)\n--password <pass> -- password (required unless --password-stdin)\n--password-stdin -- read password from stdin (recommended to avoid shell history exposure)\n--username-selector <sel> -- custom CSS selector for username field\n--password-selector <sel> -- custom CSS selector for password field\n--submit-selector <sel> -- custom CSS selector for submit button\necho \"pass\" | agent-browser auth save github --url https://github.com/login --username user --password-stdin\nagent-browser auth login github\nagent-browser auth list\nCONFIRMATION\n\nWhen --confirm-actions is set, certain action categories return a confirmation_required response instead of executing immediately. Use confirm or deny to approve or reject the action.\n\nagent-browser confirm <confirmation-id>  # Approve a pending action\nagent-browser deny <confirmation-id>     # Deny a pending action\n\nPending confirmations auto-deny after 60 seconds.\n\nagent-browser --confirm-actions eval,download eval \"document.title\"\n# Returns confirmation_required with ID\nagent-browser confirm c_8f3a1234\nSTATE MANAGEMENT\nagent-browser state save <path>       # Save auth state to file\nagent-browser state load <path>       # Load auth state from file\nagent-browser state list              # List saved state files\nagent-browser state show <file>       # Show state summary\nagent-browser state rename <old> <new> # Rename state file\nagent-browser state clear [name]      # Clear states for session name\nagent-browser state clear --all       # Clear all saved states\nagent-browser state clean --older-than <days>  # Delete old states\nSESSIONS\nagent-browser session                 # Show current session name\nagent-browser session list            # List active sessions\nNAVIGATION\nagent-browser back                    # Go back\nagent-browser forward                 # Go forward\nagent-browser reload                  # Reload page\nGLOBAL OPTIONS\n--session <name>         # Isolated browser session\n--session-name <name>    # Auto-save/restore session state (cookies, localStorage)\n--profile <path>         # Persistent browser profile directory\n--state <path>           # Load storage state from JSON file\n--headers <json>         # HTTP headers scoped to URL's origin\n--executable-path <path> # Custom browser executable\n--extension <path>       # Load browser extension (repeatable)\n--args <args>            # Browser launch args (comma separated)\n--user-agent <ua>        # Custom User-Agent string\n--proxy <url>            # Proxy server URL\n--proxy-bypass <hosts>   # Hosts to bypass proxy\n--ignore-https-errors    # Ignore HTTPS certificate errors\n--allow-file-access      # Allow file:// URLs to access local files (Chromium only)\n-p, --provider <name>    # Browser provider (ios, browserbase, kernel, browseruse)\n--device <name>          # iOS device name (e.g., \"iPhone 15 Pro\")\n--json                   # JSON output (for scripts)\n--full, -f               # Full page screenshot\n--annotate               # Annotated screenshot with numbered element labels\n--headed                 # Show browser window (not headless)\n--cdp <port|url>         # Connect via Chrome DevTools Protocol (port or WebSocket URL)\n--auto-connect           # Auto-discover and connect to running Chrome\n--color-scheme <scheme>  # Color scheme: dark, light, no-preference\n--download-path <path>   # Default download directory\n--content-boundaries     # Wrap page output in boundary markers for LLM safety\n--max-output <chars>     # Truncate page output to N characters\n--allowed-domains <list> # Comma-separated allowed domain patterns\n--action-policy <path>   # Path to action policy JSON file\n--confirm-actions <list> # Action categories requiring confirmation\n--confirm-interactive    # Interactive confirmation prompts (auto-denies if stdin is not a TTY)\n--config <path>          # Use a custom config file\n--debug                  # Debug output\nCOMMAND CHAINING\n\nChain commands with && in a single shell invocation. The browser persists via a background daemon, so chaining works naturally and is more efficient than separate calls:\n\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser snapshot -i\nagent-browser fill @e1 \"user@example.com\" && agent-browser fill @e2 \"pass\" && agent-browser click @e3\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser screenshot page.png\n\nUse && when you don't need to read intermediate output. Run commands separately when you need to parse output first (e.g., snapshot to discover refs, then interact with those refs).\n\nLOCAL FILES\n\nOpen local files (PDFs, HTML) using file:// URLs:\n\nagent-browser --allow-file-access open file:///path/to/document.pdf\nagent-browser --allow-file-access open file:///path/to/page.html\nagent-browser screenshot output.png\n\nThe --allow-file-access flag enables JavaScript to access other local files. Chromium only.\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006905,
    "timestamp": "2026-02-26T22:35:47.600Z",
    "title": "Configuration | agent-browser",
    "url": "https://agent-browser.dev/configuration",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nConfiguration\n\nCreate an agent-browser.json file to set persistent defaults instead of repeating flags on every command.\n\nCONFIG FILE LOCATIONS\n\nagent-browser checks two locations, merged in priority order:\n\nPRIORITY\tLOCATION\tSCOPE\n1 (lowest)\t~/.agent-browser/config.json\tUser-level defaults\n2\t./agent-browser.json\tProject-level overrides\n3\tAGENT_BROWSER_* env vars\tOverride config values\n4 (highest)\tCLI flags\tOverride everything\n\nProject-level values override user-level values. Environment variables override both. CLI flags always win.\n\nUse --config <path> or the AGENT_BROWSER_CONFIG environment variable to load a specific config file instead of the default locations:\n\nagent-browser --config ./ci-config.json open example.com\nAGENT_BROWSER_CONFIG=./ci-config.json agent-browser open example.com\nEXAMPLE CONFIG\n{\n  \"headed\": true,\n  \"proxy\": \"http://localhost:8080\",\n  \"profile\": \"./browser-data\",\n  \"userAgent\": \"my-agent/1.0\",\n  \"ignoreHttpsErrors\": true\n}\nALL OPTIONS\n\nEvery CLI flag can be set in the config file using its camelCase equivalent:\n\nCONFIG KEY\tCLI FLAG\tTYPE\nheaded\t--headed\tboolean\njson\t--json\tboolean\nfull\t--full, -f\tboolean\ndebug\t--debug\tboolean\nsession\t--session\tstring\nsessionName\t--session-name\tstring\nexecutablePath\t--executable-path\tstring\nextensions\t--extension\tstring[]\nprofile\t--profile\tstring\nstate\t--state\tstring\nproxy\t--proxy\tstring\nproxyBypass\t--proxy-bypass\tstring\nargs\t--args\tstring\nuserAgent\t--user-agent\tstring\nprovider\t-p, --provider\tstring\ndevice\t--device\tstring\nignoreHttpsErrors\t--ignore-https-errors\tboolean\nallowFileAccess\t--allow-file-access\tboolean\ncdp\t--cdp\tstring\nautoConnect\t--auto-connect\tboolean\ncolorScheme\t--color-scheme\tstring (dark, light, no-preference)\ndownloadPath\t--download-path\tstring\ncontentBoundaries\t--content-boundaries\tboolean\nmaxOutput\t--max-output\tnumber\nallowedDomains\t--allowed-domains\tstring[]\nactionPolicy\t--action-policy\tstring\nconfirmActions\t--confirm-actions\tstring\nconfirmInteractive\t--confirm-interactive\tboolean\nheaders\t--headers\tstring (JSON)\nCOMMON CONFIGURATIONS\nLocal Development\n{\n  \"headed\": true,\n  \"profile\": \"./browser-data\"\n}\nBehind a Proxy\n{\n  \"proxy\": \"http://proxy.corp.example.com:8080\",\n  \"proxyBypass\": \"localhost,*.internal.com\",\n  \"ignoreHttpsErrors\": true\n}\nCI / Devcontainer\n{\n  \"args\": \"--no-sandbox,--disable-gpu\",\n  \"ignoreHttpsErrors\": true\n}\niOS Testing\n{\n  \"provider\": \"ios\",\n  \"device\": \"iPhone 16 Pro\"\n}\nAI Agent Security\n{\n  \"contentBoundaries\": true,\n  \"maxOutput\": 50000,\n  \"allowedDomains\": [\"your-app.com\", \"*.your-app.com\"],\n  \"actionPolicy\": \"./policy.json\"\n}\nOVERRIDING BOOLEAN OPTIONS\n\nBoolean flags accept an optional true/false value to override config settings:\n\nagent-browser --headed false open example.com\n\nA bare flag is equivalent to passing true:\n\nagent-browser --headed open example.com       # same as --headed true\nagent-browser --headed true open example.com  # explicit\n\nThis applies to all boolean flags: --headed, --debug, --json, --ignore-https-errors, --allow-file-access, --auto-connect, --content-boundaries, --confirm-interactive.\n\nEXTENSIONS MERGING\n\nExtensions from user-level and project-level configs are concatenated, not replaced. For example, if ~/.agent-browser/config.json specifies [\"/ext1\"] and ./agent-browser.json specifies [\"/ext2\"], the result is [\"/ext1\", \"/ext2\"].\n\nThe AGENT_BROWSER_EXTENSIONS environment variable and CLI --extension flags follow the standard priority rules (env replaces config, CLI appends).\n\nENVIRONMENT VARIABLES\n\nThese environment variables configure additional daemon and runtime behavior:\n\nVARIABLE\tDESCRIPTION\tDEFAULT\nAGENT_BROWSER_AUTO_CONNECT\tAuto-discover and connect to a running Chrome instance.\t(disabled)\nAGENT_BROWSER_ALLOW_FILE_ACCESS\tAllow file:// URLs to access local files.\t(disabled)\nAGENT_BROWSER_COLOR_SCHEME\tColor scheme preference (dark, light, no-preference).\t(none)\nAGENT_BROWSER_DOWNLOAD_PATH\tDefault directory for browser downloads.\t(temp directory)\nAGENT_BROWSER_DEFAULT_TIMEOUT\tDefault Playwright timeout in ms. Keep below 30000 to avoid IPC timeouts.\t25000\nAGENT_BROWSER_SESSION_NAME\tAuto-save/load state persistence name.\t(none)\nAGENT_BROWSER_STATE_EXPIRE_DAYS\tAuto-delete saved session states older than N days.\t30\nAGENT_BROWSER_ENCRYPTION_KEY\t64-char hex key for AES-256-GCM session encryption.\t(none)\nAGENT_BROWSER_STREAM_PORT\tEnable WebSocket streaming on the specified port (e.g., 9223).\t(disabled)\nAGENT_BROWSER_IOS_DEVICE\tDefault iOS device name for the ios provider.\t(none)\nAGENT_BROWSER_IOS_UDID\tDefault iOS device UDID for the ios provider.\t(none)\nAGENT_BROWSER_DEBUG\tEnable debug output (1 to enable).\t(disabled)\nAGENT_BROWSER_CONTENT_BOUNDARIES\tWrap page output in boundary markers for LLM safety.\t(disabled)\nAGENT_BROWSER_MAX_OUTPUT\tMax characters for page output (truncates beyond limit).\t(unlimited)\nAGENT_BROWSER_ALLOWED_DOMAINS\tComma-separated allowed domain patterns (e.g., example.com,*.example.com).\t(unrestricted)\nAGENT_BROWSER_ACTION_POLICY\tPath to action policy JSON file.\t(none)\nAGENT_BROWSER_CONFIRM_ACTIONS\tComma-separated action categories requiring confirmation.\t(none)\nAGENT_BROWSER_CONFIRM_INTERACTIVE\tEnable interactive confirmation prompts (auto-denies if stdin is not a TTY).\t(disabled)\nERROR HANDLING\nAuto-discovered config files (~/.agent-browser/config.json, ./agent-browser.json) that are missing are silently ignored.\n--config <path> with a missing or malformed file exits with an error.\nMalformed JSON in auto-discovered files prints a warning to stderr and continues without that file.\nUnknown keys are silently ignored for forward compatibility.\n\nTip: If your project-level agent-browser.json contains environment-specific values (paths, proxies), consider adding it to .gitignore.\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006908,
    "timestamp": "2026-02-26T22:35:47.607Z",
    "title": "Selectors | agent-browser",
    "url": "https://agent-browser.dev/selectors",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nSelectors\nREFS (RECOMMENDED)\n\nRefs provide deterministic element selection from snapshots. Best for AI agents.\n\n# 1. Get snapshot with refs\nagent-browser snapshot\n# Output:\n# - heading \"Example Domain\" [ref=e1] [level=1]\n# - button \"Submit\" [ref=e2]\n# - textbox \"Email\" [ref=e3]\n# - link \"Learn more\" [ref=e4]\n\n# 2. Use refs to interact\nagent-browser click @e2                   # Click the button\nagent-browser fill @e3 \"test@example.com\" # Fill the textbox\nagent-browser get text @e1                # Get heading text\nagent-browser hover @e4                   # Hover the link\nWhy refs?\nDeterministic - Ref points to exact element from snapshot\nFast - No DOM re-query needed\nAI-friendly - LLMs can reliably parse and use refs\nCSS SELECTORS\nagent-browser click \"#id\"\nagent-browser click \".class\"\nagent-browser click \"div > button\"\nagent-browser click \"[data-testid='submit']\"\nTEXT & XPATH\nagent-browser click \"text=Submit\"\nagent-browser click \"xpath=//button[@type='submit']\"\nSEMANTIC LOCATORS\n\nFind elements by role, label, or other semantic properties:\n\nagent-browser find role button click --name \"Submit\"\nagent-browser find label \"Email\" fill \"test@test.com\"\nagent-browser find placeholder \"Search...\" fill \"query\"\nagent-browser find testid \"submit-btn\" click\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006911,
    "timestamp": "2026-02-26T22:35:47.608Z",
    "title": "Snapshots | agent-browser",
    "url": "https://agent-browser.dev/snapshots",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nSnapshots\n\nThe snapshot command returns a compact accessibility tree with refs for element interaction.\n\nOPTIONS\n\nFilter output to reduce size:\n\nagent-browser snapshot                    # Full accessibility tree\nagent-browser snapshot -i                 # Interactive elements only (recommended)\nagent-browser snapshot -i -C              # Include cursor-interactive elements\nagent-browser snapshot -c                 # Compact (remove empty elements)\nagent-browser snapshot -d 3               # Limit depth to 3 levels\nagent-browser snapshot -s \"#main\"         # Scope to CSS selector\nagent-browser snapshot -i -c -d 5         # Combine options\nOPTION\tDESCRIPTION\n-i, --interactive\tOnly interactive elements (buttons, links, inputs)\n-C, --cursor\tInclude cursor-interactive elements (cursor:pointer, onclick, tabindex)\n-c, --compact\tRemove empty structural elements\n-d, --depth\tLimit tree depth\n-s, --selector\tScope to CSS selector\nCURSOR-INTERACTIVE ELEMENTS\n\nMany modern web apps use custom clickable elements (divs, spans) instead of standard buttons or links. The -C flag detects these by looking for:\n\ncursor: pointer CSS style\nonclick attribute or handler\ntabindex attribute (keyboard focusable)\nagent-browser snapshot -i -C\n# Output includes:\n# @e1 [button] \"Submit\"\n# @e2 [link] \"Learn more\"\n# Cursor-interactive elements:\n# @e3 [clickable] \"Menu Item\" [cursor:pointer, onclick]\n# @e4 [clickable] \"Card\" [cursor:pointer]\nOUTPUT FORMAT\n\nThe default text output is compact and AI-friendly:\n\nagent-browser snapshot -i\n# Output:\n# @e1 [heading] \"Example Domain\" [level=1]\n# @e2 [button] \"Submit\"\n# @e3 [input type=\"email\"] placeholder=\"Email\"\n# @e4 [link] \"Learn more\"\nUSING REFS\n\nRefs from the snapshot map directly to commands:\n\nagent-browser click @e2      # Click the Submit button\nagent-browser fill @e3 \"a@b.com\"  # Fill the email input\nagent-browser get text @e1        # Get heading text\nREF LIFECYCLE\n\nRefs are invalidated when the page changes. Always re-snapshot after navigation or DOM updates:\n\nagent-browser click @e4      # Navigates to new page\nagent-browser snapshot -i    # Get fresh refs\nagent-browser click @e1      # Use new refs\nANNOTATED SCREENSHOTS\n\nFor visual context alongside text snapshots, use screenshot --annotate to overlay numbered labels on interactive elements. Each label [N] maps to ref @eN:\n\nagent-browser screenshot --annotate ./page.png\n# -> Screenshot saved to ./page.png\n#    [1] @e1 button \"Submit\"\n#    [2] @e2 link \"Home\"\n#    [3] @e3 textbox \"Email\"\nagent-browser click @e2\n\nAnnotated screenshots also cache refs, so you can interact with elements immediately. This is useful when the text snapshot is insufficient -- unlabeled icons, canvas content, or visual layout verification.\n\nBEST PRACTICES\nUse -i to reduce output to actionable elements\nRe-snapshot after page changes to get updated refs\nScope with -s for specific page sections\nUse -d to limit depth on complex pages\nUse screenshot --annotate when visual context is needed alongside refs\nJSON OUTPUT\n\nFor programmatic parsing in scripts:\n\nagent-browser snapshot --json\n# {\"success\":true,\"data\":{\"snapshot\":\"...\",\"refs\":{\"e1\":{\"role\":\"heading\",\"name\":\"Title\"},...}}}\n\nNote: JSON uses more tokens than text output. The default text format is preferred for AI agents.\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006914,
    "timestamp": "2026-02-26T22:35:47.608Z",
    "title": "Sessions | agent-browser",
    "url": "https://agent-browser.dev/sessions",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nSessions\n\nRun multiple isolated browser instances:\n\n# Different sessions\nagent-browser --session agent1 open site-a.com\nagent-browser --session agent2 open site-b.com\n\n# Or via environment variable\nAGENT_BROWSER_SESSION=agent1 agent-browser click \"#btn\"\n\n# List active sessions\nagent-browser session list\n# Output:\n# Active sessions:\n# -> default\n#    agent1\n\n# Show current session\nagent-browser session\nSESSION ISOLATION\n\nEach session has its own:\n\nBrowser instance\nCookies and storage\nNavigation history\nAuthentication state\nPERSISTENT PROFILES\n\nBy default, browser state is lost when the browser closes. Use --profile to persist state across restarts:\n\n# Use a persistent profile directory\nagent-browser --profile ~/.myapp-profile open myapp.com\n\n# Login once, then reuse the authenticated session\nagent-browser --profile ~/.myapp-profile open myapp.com/dashboard\n\n# Or via environment variable\nAGENT_BROWSER_PROFILE=~/.myapp-profile agent-browser open myapp.com\n\nThe profile directory stores:\n\nCookies and localStorage\nIndexedDB data\nService workers\nBrowser cache\nLogin sessions\nSESSION PERSISTENCE\n\nUse --session-name to automatically save and restore cookies and localStorage across browser restarts:\n\n# Auto-save/load state for \"twitter\" session\nagent-browser --session-name twitter open twitter.com\n\n# Login once, then state persists automatically\nagent-browser --session-name twitter click \"#login\"\n\n# Or via environment variable\nexport AGENT_BROWSER_SESSION_NAME=twitter\nagent-browser open twitter.com\n\nState files are stored in ~/.agent-browser/sessions/ and automatically loaded on daemon start.\n\nSession name rules\n\nSession names must contain only alphanumeric characters, hyphens, and underscores:\n\n# Valid session names\nagent-browser --session-name my-project open example.com\nagent-browser --session-name test_session_v2 open example.com\n\n# Invalid (will be rejected)\nagent-browser --session-name \"../bad\" open example.com    # path traversal\nagent-browser --session-name \"my session\" open example.com # spaces\nagent-browser --session-name \"foo/bar\" open example.com    # slashes\nSTATE ENCRYPTION\n\nEncrypt saved state files (cookies, localStorage) using AES-256-GCM:\n\n# Generate a 256-bit key (64 hex characters)\nopenssl rand -hex 32\n\n# Set the encryption key\nexport AGENT_BROWSER_ENCRYPTION_KEY=<your-64-char-hex-key>\n\n# State files are now encrypted automatically\nagent-browser --session-name secure-session open example.com\n\n# List states shows encryption status\nagent-browser state list\nSTATE AUTO-EXPIRATION\n\nAutomatically delete old state files to prevent accumulation:\n\n# Set expiration (default: 30 days)\nexport AGENT_BROWSER_STATE_EXPIRE_DAYS=7\n\n# Manually clean old states\nagent-browser state clean --older-than 7\nSTATE MANAGEMENT COMMANDS\n# List all saved states\nagent-browser state list\n\n# Show state summary (cookies, origins, domains)\nagent-browser state show my-session-default.json\n\n# Rename a state file\nagent-browser state rename old-name new-name\n\n# Clear states for a specific session name\nagent-browser state clear my-session\n\n# Clear all saved states\nagent-browser state clear --all\n\n# Manual save/load (for custom paths)\nagent-browser state save ./backup.json\nagent-browser state load ./backup.json\nAUTHENTICATED SESSIONS\n\nUse --headers to set HTTP headers for a specific origin:\n\n# Headers scoped to api.example.com only\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer <token>\"}'\n\n# Requests to api.example.com include the auth header\nagent-browser snapshot -i --json\nagent-browser click @e2\n\n# Navigate to another domain - headers NOT sent\nagent-browser open other-site.com\n\nUseful for:\n\nSkipping login flows - Authenticate via headers\nSwitching users - Different auth tokens per session\nAPI testing - Access protected endpoints\nSecurity - Headers scoped to origin, not leaked\nMULTIPLE ORIGINS\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer token1\"}'\nagent-browser open api.acme.com --headers '{\"Authorization\": \"Bearer token2\"}'\nGLOBAL HEADERS\n\nFor headers on all domains:\n\nagent-browser set headers '{\"X-Custom-Header\": \"value\"}'\nENVIRONMENT VARIABLES\nVARIABLE\tDESCRIPTION\nAGENT_BROWSER_SESSION\tBrowser session ID (default: \"default\")\nAGENT_BROWSER_SESSION_NAME\tAuto-save/load state persistence name\nAGENT_BROWSER_ENCRYPTION_KEY\t64-char hex key for AES-256-GCM encryption\nAGENT_BROWSER_STATE_EXPIRE_DAYS\tAuto-delete states older than N days (default: 30)\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006918,
    "timestamp": "2026-02-26T22:35:47.611Z",
    "title": "CDP Mode | agent-browser",
    "url": "https://agent-browser.dev/cdp-mode",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nCDP Mode\n\nConnect to an existing browser via Chrome DevTools Protocol:\n\n# Start Chrome with: google-chrome --remote-debugging-port=9222\n\n# Connect once, then run commands without --cdp\nagent-browser connect 9222\nagent-browser snapshot\nagent-browser tab\nagent-browser close\n\n# Or pass --cdp on each command\nagent-browser --cdp 9222 snapshot\nREMOTE WEBSOCKET URLS\n\nConnect to remote browser services via WebSocket URL:\n\n# Connect to remote browser service\nagent-browser --cdp \"wss://browser-service.com/cdp?token=...\" snapshot\n\n# Works with any CDP-compatible service\nagent-browser --cdp \"ws://localhost:9222/devtools/browser/abc123\" open example.com\n\nThe --cdp flag accepts either:\n\nA port number (e.g., 9222) for local connections via http://localhost:{port}\nA full WebSocket URL (e.g., wss://... or ws://...) for remote browser services\nAUTO-CONNECT\n\nUse --auto-connect to automatically discover and connect to a running Chrome instance without specifying a port:\n\n# Auto-discover running Chrome with remote debugging\nagent-browser --auto-connect open example.com\nagent-browser --auto-connect snapshot\n\n# Or via environment variable\nAGENT_BROWSER_AUTO_CONNECT=1 agent-browser snapshot\n\nAuto-connect discovers Chrome by:\n\nReading Chrome's DevToolsActivePort file from the default user data directory\nFalling back to probing common debugging ports (9222, 9229)\n\nThis is useful when:\n\nChrome 144+ has remote debugging enabled via chrome://inspect/#remote-debugging (which uses a dynamic port)\nYou want a zero-configuration connection to your existing browser\nYou don't want to track which port Chrome is using\nCOLOR SCHEME\n\nPlaywright overrides the browser's color scheme to light by default when connecting via CDP. Use --color-scheme to set a persistent preference:\n\nagent-browser --cdp 9222 --color-scheme dark open https://example.com\nagent-browser --cdp 9222 snapshot  # stays in dark mode\n\nOr set it globally via config or environment variable:\n\nAGENT_BROWSER_COLOR_SCHEME=dark agent-browser --cdp 9222 open https://example.com\nUSE CASES\n\nThis enables control of:\n\nElectron apps\nChrome/Chromium with remote debugging\nWebView2 applications\nRemote browser services (via WebSocket URL)\nAny browser exposing a CDP endpoint\nGLOBAL OPTIONS\nOPTION\tDESCRIPTION\n--session <name>\tUse isolated session\n--profile <path>\tPersistent browser profile directory\n-p <provider>\tCloud browser provider (browserbase, browseruse, kernel)\n--headers <json>\tHTTP headers scoped to origin\n--executable-path\tCustom browser executable\n--args <args>\tBrowser launch args (comma-separated)\n--user-agent <ua>\tCustom User-Agent string\n--proxy <url>\tProxy server URL\n--proxy-bypass <hosts>\tHosts to bypass proxy\n--json\tJSON output for scripts\n--full, -f\tFull page screenshot\n--name, -n\tLocator name filter\n--exact\tExact text match\n--headed\tShow browser window\n--cdp <port|url>\tCDP connection (port or WebSocket URL)\n--auto-connect\tAuto-discover and connect to running Chrome\n--color-scheme <scheme>\tPersistent color scheme (dark, light, no-preference)\n--debug\tDebug output\nCLOUD PROVIDERS\n\nUse cloud browser infrastructure when local browsers aren't available:\n\n# Browserbase\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser -p browserbase open https://example.com\n\n# Browser Use\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser -p browseruse open https://example.com\n\n# Kernel\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser -p kernel open https://example.com\n\n# Or via environment variable\nexport AGENT_BROWSER_PROVIDER=browserbase\nagent-browser open https://example.com\n\nThe -p flag takes precedence over AGENT_BROWSER_PROVIDER.\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006917,
    "timestamp": "2026-02-26T22:35:47.612Z",
    "title": "Diffing | agent-browser",
    "url": "https://agent-browser.dev/diffing",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nDiffing\n\nCompare page states to detect changes -- structurally via accessibility tree snapshots, visually via pixel comparison, or across two different URLs.\n\nVERIFY AN ACTION CHANGED THE PAGE\n$ agent-browser snapshot -i\n$ agent-browser fill @e3 \"test@example.com\"\n$ agent-browser click @e4\n$ agent-browser diff snapshot\nheading \"Sign Up\" [ref=e1]\ntext \"Create your account\" [ref=e2]\n- textbox \"Email\" [ref=e3]\n+ textbox \"Email\" [ref=e3]: \"test@example.com\"\n- button \"Submit\" [ref=e4]\n+ button \"Submit\" [ref=e4] [disabled]\n+ status \"Sending...\" [ref=e7]\nlink \"Already have an account?\" [ref=e5]\n3 additions, 2 removals, 3 unchanged\nCATCH A VISUAL REGRESSION\n$ agent-browser diff screenshot --baseline before-deploy.png\n✗ 2.37% pixels differ\nDiff image: ~/.agent-browser/tmp/diffs/diff-1708473621.png\n1,137 different / 48,000 total pixels\nBaseline\nSubmit\nCurrent\nSubmit\nDiff\nSubmit\nCOMMANDS\nCOMMAND\tDESCRIPTION\ndiff snapshot\tCompare current snapshot to last snapshot in session\ndiff snapshot --baseline <file>\tCompare current snapshot to a saved file\ndiff screenshot --baseline <file>\tVisual pixel diff against a baseline image\ndiff url <url1> <url2>\tCompare two pages (snapshot + optional screenshot)\nSNAPSHOT DIFF\n\nCompares the accessibility tree between two points in time using a line-level text diff.\n\n# Compare against the last snapshot taken in this session\nagent-browser diff snapshot\n\n# Compare against a saved baseline file\nagent-browser diff snapshot --baseline before.txt\n\n# Scope to a specific part of the page\nagent-browser diff snapshot --selector \"#main\" --compact\n\nWithout --baseline, the command automatically compares against the most recent snapshot taken in the current session. This is the primary use case for agents verifying that an action had the intended effect.\n\nOptions\nFLAG\tDESCRIPTION\n-b, --baseline <file>\tPath to a saved snapshot file to compare against\n-s, --selector <sel>\tScope the current snapshot to a CSS selector or @ref\n-c, --compact\tUse compact snapshot format\n-d, --depth <n>\tLimit snapshot tree depth\nOutput\n\nThe diff uses + for added lines and - for removed lines, similar to unified diff format. A summary line shows the count of additions, removals, and unchanged lines.\n\n- button \"Submit\" [ref=e2]\n+ button \"Submit\" [ref=e2] [disabled]\n  3 additions, 2 removals, 41 unchanged\nSCREENSHOT DIFF\n\nCompares the current page screenshot against a baseline image at the pixel level. Produces a diff image with changed pixels highlighted in red.\n\n# Basic visual diff\nagent-browser diff screenshot --baseline before.png\n\n# Save diff image to a specific path\nagent-browser diff screenshot --baseline before.png --output diff.png\n\n# Adjust threshold and scope to element\nagent-browser diff screenshot --baseline before.png --threshold 0.2 --selector \"#hero\"\nOptions\nFLAG\tDESCRIPTION\n-b, --baseline <file>\tBaseline PNG/JPEG image to compare against (required)\n-o, --output <file>\tPath for the generated diff image (default: temp dir)\n-t, --threshold <0-1>\tColor distance threshold (default: 0.1). Higher = more tolerant\n-s, --selector <sel>\tScope the current screenshot to an element\n--full\tTake a full-page screenshot\nOutput\n\nReports the diff image path, number of different pixels, and mismatch percentage. The diff image shows unchanged pixels dimmed with changed pixels in red.\n\nIf the baseline and current images have different dimensions, the command reports a dimension mismatch instead of attempting pixel comparison.\n\nURL DIFF\n\nCompares two pages by navigating to each in sequence and diffing the results.\n\n# Compare two URLs (snapshot diff)\nagent-browser diff url https://staging.example.com https://prod.example.com\n\n# Include visual comparison\nagent-browser diff url https://v1.example.com https://v2.example.com --screenshot\n\n# Full-page screenshot comparison\nagent-browser diff url https://v1.example.com https://v2.example.com --screenshot --full\n\nThe command navigates to the first URL, captures state, then navigates to the second URL and captures again. Snapshot diff is always included. Screenshot diff requires the --screenshot flag.\n\nAfter completion, the browser remains on the second URL.\n\nOptions\nFLAG\tDESCRIPTION\n--screenshot\tAlso perform visual screenshot comparison\n--full\tUse full-page screenshots\n--wait-until <strategy>\tNavigation wait strategy: load, domcontentloaded, networkidle (default: load)\n-s, --selector <sel>\tScope snapshots to a CSS selector or @ref\n-c, --compact\tUse compact snapshot format\n-d, --depth <n>\tLimit snapshot tree depth\nUSE CASES\nVerifying agent actions\n\nThe most common use case: confirm that an action (click, fill, submit) changed the page as expected.\n\nagent-browser snapshot -i          # Take interactive-only snapshot (baseline)\nagent-browser fill @e3 \"test@example.com\"\nagent-browser diff snapshot        # Compare current snapshot to the baseline\nMonitoring for changes\n\nPeriodically compare a page against a saved baseline to detect updates.\n\n# Save baseline\nagent-browser open https://example.com && agent-browser snapshot > baseline.txt\n\n# Later, check for changes\nagent-browser open https://example.com && agent-browser diff snapshot --baseline baseline.txt\nVisual regression testing\n\nCompare screenshots before and after a deploy to catch unintended visual changes.\n\nagent-browser open https://staging.example.com && agent-browser screenshot baseline.png\n# ... deploy happens ...\nagent-browser open https://staging.example.com && agent-browser diff screenshot --baseline baseline.png\nComparing environments\n\nDiff staging against production to verify parity.\n\nagent-browser diff url https://staging.example.com https://prod.example.com --screenshot\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006923,
    "timestamp": "2026-02-26T22:35:47.612Z",
    "title": "Streaming | agent-browser",
    "url": "https://agent-browser.dev/streaming",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nStreaming\n\nStream the browser viewport via WebSocket for live preview or \"pair browsing\" where a human can watch and interact alongside an AI agent.\n\nENABLE STREAMING\n\nSet the AGENT_BROWSER_STREAM_PORT environment variable to start a WebSocket server:\n\nAGENT_BROWSER_STREAM_PORT=9223 agent-browser open example.com\n\nThe server streams viewport frames and accepts input events (mouse, keyboard, touch).\n\nWEBSOCKET PROTOCOL\n\nConnect to ws://localhost:9223 to receive frames and send input.\n\nFrame messages\n\nThe server sends frame messages with base64-encoded images:\n\n{\n  \"type\": \"frame\",\n  \"data\": \"<base64-encoded-jpeg>\",\n  \"metadata\": {\n    \"deviceWidth\": 1280,\n    \"deviceHeight\": 720,\n    \"pageScaleFactor\": 1,\n    \"offsetTop\": 0,\n    \"scrollOffsetX\": 0,\n    \"scrollOffsetY\": 0\n  }\n}\nStatus messages\n\nConnection and screencast status:\n\n{\n  \"type\": \"status\",\n  \"connected\": true,\n  \"screencasting\": true,\n  \"viewportWidth\": 1280,\n  \"viewportHeight\": 720\n}\nINPUT INJECTION\n\nSend input events to control the browser remotely.\n\nMouse events\n// Click\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mousePressed\",\n  \"x\": 100,\n  \"y\": 200,\n  \"button\": \"left\",\n  \"clickCount\": 1\n}\n\n// Release\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mouseReleased\",\n  \"x\": 100,\n  \"y\": 200,\n  \"button\": \"left\"\n}\n\n// Move\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mouseMoved\",\n  \"x\": 150,\n  \"y\": 250\n}\n\n// Scroll\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mouseWheel\",\n  \"x\": 100,\n  \"y\": 200,\n  \"deltaX\": 0,\n  \"deltaY\": 100\n}\nKeyboard events\n// Key down\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"keyDown\",\n  \"key\": \"Enter\",\n  \"code\": \"Enter\"\n}\n\n// Key up\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"keyUp\",\n  \"key\": \"Enter\",\n  \"code\": \"Enter\"\n}\n\n// Type character\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"char\",\n  \"text\": \"a\"\n}\n\n// With modifiers (1=Alt, 2=Ctrl, 4=Meta, 8=Shift)\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"keyDown\",\n  \"key\": \"c\",\n  \"code\": \"KeyC\",\n  \"modifiers\": 2\n}\nTouch events\n// Touch start\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchStart\",\n  \"touchPoints\": [{ \"x\": 100, \"y\": 200 }]\n}\n\n// Touch move\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchMove\",\n  \"touchPoints\": [{ \"x\": 150, \"y\": 250 }]\n}\n\n// Touch end\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchEnd\",\n  \"touchPoints\": []\n}\n\n// Multi-touch (pinch zoom)\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchStart\",\n  \"touchPoints\": [\n    { \"x\": 100, \"y\": 200, \"id\": 0 },\n    { \"x\": 200, \"y\": 200, \"id\": 1 }\n  ]\n}\nPROGRAMMATIC API\n\nFor advanced use, control streaming directly via the TypeScript API:\n\nimport { BrowserManager } from 'agent-browser';\n\nconst browser = new BrowserManager();\nawait browser.launch({ headless: true });\nawait browser.navigate('https://example.com');\n\n// Start screencast with callback\nawait browser.startScreencast((frame) => {\n  console.log('Frame:', frame.metadata.deviceWidth, 'x', frame.metadata.deviceHeight);\n  // frame.data is base64-encoded image\n}, {\n  format: 'jpeg',  // or 'png'\n  quality: 80,     // 0-100, jpeg only\n  maxWidth: 1280,\n  maxHeight: 720,\n  everyNthFrame: 1\n});\n\n// Inject mouse event\nawait browser.injectMouseEvent({\n  type: 'mousePressed',\n  x: 100,\n  y: 200,\n  button: 'left',\n  clickCount: 1\n});\n\n// Inject keyboard event\nawait browser.injectKeyboardEvent({\n  type: 'keyDown',\n  key: 'Enter',\n  code: 'Enter'\n});\n\n// Inject touch event\nawait browser.injectTouchEvent({\n  type: 'touchStart',\n  touchPoints: [{ x: 100, y: 200 }]\n});\n\n// Check if screencasting\nconsole.log('Active:', browser.isScreencasting());\n\n// Stop screencast\nawait browser.stopScreencast();\nUSE CASES\nPair browsing - Human watches and assists AI agent in real-time\nRemote preview - View browser output in a separate UI\nRecording - Capture frames for video generation\nMobile testing - Inject touch events for mobile emulation\nAccessibility testing - Manual interaction during automated tests\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006927,
    "timestamp": "2026-02-26T22:35:47.616Z",
    "title": "iOS Simulator | agent-browser",
    "url": "https://agent-browser.dev/ios",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\niOS Simulator\n\nControl real Mobile Safari in the iOS Simulator for authentic mobile web testing. Uses Appium with XCUITest for native automation.\n\nREQUIREMENTS\nmacOS with Xcode installed\niOS Simulator runtimes (download via Xcode)\nAppium with XCUITest driver\nSETUP\n# Install Appium globally\nnpm install -g appium\n\n# Install the XCUITest driver for iOS\nappium driver install xcuitest\nLIST AVAILABLE DEVICES\n\nSee all iOS simulators available on your system:\n\nagent-browser device list\n\n# Output:\n# Available iOS Simulators:\n#\n#   ○ iPhone 16 Pro (iOS 18.0)\n#     F21EEC0D-7618-419F-811B-33AF27A8B2FD\n#   ○ iPhone 16 Pro Max (iOS 18.0)\n#     50402807-C9B8-4D37-9F13-2E00E782C744\n#   ○ iPad Pro 13-inch (M4) (iOS 18.0)\n#     3A6C6436-B909-4593-866D-91D1062BB070\n#   ...\nBASIC USAGE\n\nUse the -p ios flag to enable iOS mode. The workflow is identical to desktop:\n\n# Launch Safari on iPhone 16 Pro\nagent-browser -p ios --device \"iPhone 16 Pro\" open https://example.com\n\n# Get snapshot with refs (same as desktop)\nagent-browser -p ios snapshot -i\n\n# Interact using refs\nagent-browser -p ios tap @e1\nagent-browser -p ios fill @e2 \"text\"\n\n# Take screenshot\nagent-browser -p ios screenshot mobile.png\n\n# Close session (shuts down simulator)\nagent-browser -p ios close\nMOBILE-SPECIFIC COMMANDS\n# Swipe gestures\nagent-browser -p ios swipe up\nagent-browser -p ios swipe down\nagent-browser -p ios swipe left\nagent-browser -p ios swipe right\n\n# Swipe with distance (pixels)\nagent-browser -p ios swipe up 500\n\n# Tap (alias for click, semantically clearer for touch)\nagent-browser -p ios tap @e1\nENVIRONMENT VARIABLES\n\nConfigure iOS mode via environment variables:\n\nexport AGENT_BROWSER_PROVIDER=ios\nexport AGENT_BROWSER_IOS_DEVICE=\"iPhone 16 Pro\"\n\n# Now all commands use iOS\nagent-browser open https://example.com\nagent-browser snapshot -i\nagent-browser tap @e1\nVARIABLE\tDESCRIPTION\nAGENT_BROWSER_PROVIDER\tSet to ios to enable iOS mode\nAGENT_BROWSER_IOS_DEVICE\tDevice name (e.g., \"iPhone 16 Pro\")\nAGENT_BROWSER_IOS_UDID\tDevice UDID (alternative to device name)\nSUPPORTED DEVICES\n\nAll iOS Simulators available in Xcode are supported, including:\n\nAll iPhone models (iPhone 15, 16, 17, SE, etc.)\nAll iPad models (iPad Pro, iPad Air, iPad mini, etc.)\nMultiple iOS versions (17.x, 18.x, etc.)\n\nReal devices are also supported via USB connection (see below).\n\nREAL DEVICE SUPPORT\n\nAppium can control Safari on real iOS devices connected via USB. This requires additional one-time setup.\n\n1. Get your device UDID\n# List connected devices\nxcrun xctrace list devices\n\n# Or via system profiler\nsystem_profiler SPUSBDataType | grep -A 5 \"iPhone\\|iPad\"\n2. Sign WebDriverAgent (one-time)\n\nWebDriverAgent needs to be signed with your Apple Developer certificate to run on real devices.\n\n# Open the WebDriverAgent Xcode project\ncd ~/.appium/node_modules/appium-xcuitest-driver/node_modules/appium-webdriveragent\nopen WebDriverAgent.xcodeproj\n\nIn Xcode:\n\nSelect the WebDriverAgentRunner target\nGo to Signing & Capabilities\nSelect your Team (requires Apple Developer account, free tier works)\nLet Xcode manage signing automatically\n3. Use with agent-browser\n# Connect device via USB, then use the UDID\nagent-browser -p ios --device \"<DEVICE_UDID>\" open https://example.com\n\n# Or use the device name if unique\nagent-browser -p ios --device \"John's iPhone\" open https://example.com\nReal device notes\nFirst run installs WebDriverAgent to the device (may require Trust prompt on device)\nDevice must be unlocked and connected via USB\nSlightly slower initial connection than simulator\nTests against real Safari performance and behavior\nOn first install, go to Settings → General → VPN & Device Management to trust the developer certificate\nPERFORMANCE NOTES\nFirst launch: Takes 30-60 seconds to boot the simulator and start Appium\nSubsequent commands: Fast (simulator stays running)\nClose command: Shuts down simulator and Appium server\nDIFFERENCES FROM DESKTOP\nFEATURE\tDESKTOP\tIOS\nBrowser\tChromium/Firefox/WebKit\tSafari only\nTabs\tSupported\tSingle tab only\nPDF export\tSupported\tNot supported\nScreencast\tSupported\tNot supported\nSwipe gestures\tNot native\tNative support\nTROUBLESHOOTING\nAppium not found\n# Make sure Appium is installed globally\nnpm install -g appium\nappium driver install xcuitest\n\n# Verify installation\nappium --version\nNo simulators available\n\nOpen Xcode and download iOS Simulator runtimes from Settings → Platforms.\n\nSimulator won't boot\n\nTry booting the simulator manually from Xcode or the Simulator app to ensure it works, then retry with agent-browser.\n\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006926,
    "timestamp": "2026-02-26T22:35:47.616Z",
    "title": "Profiler | agent-browser",
    "url": "https://agent-browser.dev/profiler",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nProfiler\n\nCapture Chrome DevTools performance profiles during browser automation. Use profiles to diagnose slow page loads, expensive JavaScript, layout thrashing, and other performance bottlenecks in agentic workflows.\n\nBASIC USAGE\n# Start profiling\nagent-browser profiler start\n\n# Perform actions\nagent-browser navigate https://example.com\nagent-browser click \"#button\"\n\n# Stop and save profile\nagent-browser profiler stop ./trace.json\n\nThe output JSON file can be loaded into Chrome DevTools, Perfetto UI, or any tool that accepts Chrome Trace Event format.\n\nCOMMANDS\nCOMMAND\tDESCRIPTION\nprofiler start\tStart recording a performance profile\nprofiler start --categories <list>\tStart with custom trace categories\nprofiler stop [path]\tStop profiling and save to file\nTRACE CATEGORIES\n\nThe --categories flag accepts a comma-separated list of Chrome trace categories.\n\nagent-browser profiler start --categories \"devtools.timeline,v8.execute,blink.user_timing\"\n\nDefault categories include devtools.timeline, v8.execute, blink, blink.user_timing, latencyInfo, renderer.scheduler, toplevel, and several disabled-by-default-* categories for detailed CPU profiling and call stack analysis.\n\nCommon categories\nCATEGORY\tWHAT IT CAPTURES\ndevtools.timeline\tStandard DevTools performance events\nv8.execute\tTime spent running JavaScript\nblink\tRenderer events (layout, paint, style)\nblink.user_timing\tperformance.mark() and performance.measure() calls\nlatencyInfo\tInput-to-display latency\ndisabled-by-default-v8.cpu_profiler\tSampling-based JS CPU profiling\nOUTPUT FORMAT\n\nThe output is a JSON file in Chrome Trace Event format:\n\n{\n  \"traceEvents\": [\n    {\n      \"cat\": \"devtools.timeline\",\n      \"name\": \"RunTask\",\n      \"ph\": \"X\",\n      \"ts\": 12345,\n      \"dur\": 100,\n      \"pid\": 1,\n      \"tid\": 1\n    }\n  ],\n  \"metadata\": {\n    \"clock-domain\": \"LINUX_CLOCK_MONOTONIC\"\n  }\n}\n\nThe metadata.clock-domain field reflects the host platform (Linux or macOS). On Windows it is omitted.\n\nVIEWING PROFILES\nChrome DevTools -- Performance panel > Load profile\nPerfetto -- https://ui.perfetto.dev/ (drag and drop the JSON file)\nTrace Viewer -- chrome://tracing in any Chromium browser\nUSE CASES\nPage load analysis -- Profile navigation to identify slow resources, long tasks, or layout shifts\nInteraction profiling -- Measure the cost of clicks, form fills, and other user interactions\nCI regression checks -- Capture profiles per build and compare trace data over time\nAgent workflow optimization -- Find which steps in an agentic flow are most expensive\nLIMITATIONS\nOnly works with Chromium-based browsers (Chrome, Edge). Not supported on Firefox or WebKit.\nTrace data accumulates in memory while profiling is active (capped at 5 million events). Stop profiling promptly after the area of interest.\nData collection on stop has a 30-second timeout. If the browser is unresponsive, the stop command may fail.\nWhen no output path is provided, the profile is saved to an auto-generated path under the agent-browser temp directory.\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006930,
    "timestamp": "2026-02-26T22:35:47.616Z",
    "title": "Security | agent-browser",
    "url": "https://agent-browser.dev/security",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nSecurity\n\nagent-browser includes security features to protect against credential exposure, prompt injection via untrusted page content, and unauthorized browser actions.\n\nAll security features are opt-in. By default, agent-browser imposes no restrictions on navigation, actions, or output. Enable these features as needed for your deployment -- existing workflows are unaffected until you explicitly activate a feature.\n\nTHREAT MODEL\n\nThese features are designed to mitigate the following threats when an LLM-based agent drives a browser:\n\nCredential exposure -- Passwords stored in the auth vault are never included in LLM context. The CLI handles vault operations locally; credentials do not pass through the daemon's IPC channel.\nPrompt injection via page content -- Malicious pages can embed text that looks like tool output or system instructions. Content boundary markers (--content-boundaries) let the orchestrator distinguish trusted tool output from untrusted page content.\nUnauthorized navigation / data exfiltration -- A compromised or manipulated agent could navigate to attacker-controlled domains to exfiltrate data. The domain allowlist (--allowed-domains) blocks navigations, sub-resource requests, WebSocket connections, EventSource streams, and sendBeacon calls to non-allowed domains.\nUnauthorized destructive actions -- Action policy (--action-policy) and confirmation gating (--confirm-actions) prevent the agent from performing dangerous operations (eval, downloads, uploads) without explicit approval.\nContext flooding -- Large page outputs can overwhelm an LLM's context window. Output truncation (--max-output) caps the size of page-sourced content.\nKnown limitations\nWebSocket/EventSource blocking is best-effort. It works by overriding browser constructors via an init script. If the eval action category is allowed, page scripts could theoretically restore the original constructors. Deny eval via --action-policy for maximum protection.\nDomain filter timing on remote connections. When connecting to a pre-existing browser via CDP or a cloud provider, pages may have already loaded content before the domain filter is installed. agent-browser navigates disallowed pages to about:blank after the filter is active, but resources loaded before that point are not retroactively blocked.\nContent boundaries are defense-in-depth. They rely on the LLM and orchestrator respecting the structural markers. A sufficiently capable adversarial page could attempt to mimic the boundary format, though the per-process CSPRNG nonce makes this impractical to predict.\nConfirmation timeout. Pending confirmations auto-deny after 60 seconds. Orchestrators must respond within that window.\nNon-TTY auto-deny. When --confirm-interactive is set but stdin is not a terminal (e.g., piped input), actions are automatically denied to prevent accidental approval in non-interactive contexts.\nAUTHENTICATION VAULT\n\nStore credentials locally and reference them by name. The LLM never sees passwords.\n\n# Save credentials (encrypted if AGENT_BROWSER_ENCRYPTION_KEY is set)\n# Recommended: pipe password via stdin to avoid shell history / process listing exposure\necho \"pass\" | agent-browser auth save github --url https://github.com/login --username user --password-stdin\n\n# Or pass directly (a warning will be shown)\nagent-browser auth save github --url https://github.com/login --username user --password pass\n\n# Login using saved credentials\nagent-browser auth login github\n\n# List saved profiles (names and URLs only, no secrets)\nagent-browser auth list\n\n# Show profile metadata\nagent-browser auth show github\n\n# Delete a profile\nagent-browser auth delete github\n\nCustom selectors can be specified if auto-detection fails:\n\nagent-browser auth save myapp \\\n  --url https://app.example.com/login \\\n  --username user --password pass \\\n  --username-selector \"#email\" \\\n  --password-selector \"#password\" \\\n  --submit-selector \"button.login\"\n\nProfiles are stored in ~/.agent-browser/auth/ and always encrypted with AES-256-GCM. If AGENT_BROWSER_ENCRYPTION_KEY is not set, a key is auto-generated at ~/.agent-browser/.encryption-key on first use. Back up this file or set the environment variable explicitly for portability.\n\nFile permissions are enforced on both Unix (chmod 600/700) and Windows (icacls restricted to the current user) to prevent other users from reading encryption keys or auth profiles.\n\nCONTENT BOUNDARY MARKERS\n\nWhen --content-boundaries is enabled, all page-sourced output is wrapped in structural markers so LLMs can distinguish tool output from untrusted page content:\n\n--- AGENT_BROWSER_PAGE_CONTENT nonce=a1b2c3d4 origin=https://example.com ---\n[snapshot / text / html / eval output here]\n--- END_AGENT_BROWSER_PAGE_CONTENT nonce=a1b2c3d4 ---\n\nThe nonce is a random value generated per CLI process invocation, making it unpredictable to page content that might attempt to spoof the boundary.\n\nEnable via flag or environment variable:\n\nagent-browser --content-boundaries snapshot\n# or\nexport AGENT_BROWSER_CONTENT_BOUNDARIES=1\n\nAffected output types: snapshot, get text, get html, eval, console.\n\nIn --json mode, boundary metadata is injected into the JSON response as a _boundary object containing nonce and origin fields, allowing orchestrators to verify provenance programmatically:\n\n{\n  \"success\": true,\n  \"data\": { \"snapshot\": \"...\", \"origin\": \"https://example.com\" },\n  \"_boundary\": { \"nonce\": \"a1b2c3d4e5f6...\", \"origin\": \"https://example.com\" }\n}\nDOMAIN ALLOWLIST\n\nRestrict which domains the browser can interact with, preventing redirect-based attacks and data exfiltration:\n\nagent-browser --allowed-domains \"example.com,*.example.com,github.com\" open https://example.com\n# or\nexport AGENT_BROWSER_ALLOWED_DOMAINS=\"example.com,*.example.com\"\n\nSupports exact match (github.com) and wildcard prefix (*.example.com, which also matches the bare domain example.com). Both page navigations and sub-resource requests (scripts, images, fetch, XHR, etc.) to non-allowed domains are blocked, preventing data exfiltration. WebSocket and EventSource connections are also blocked via constructor-level patching. Non-http(s) sub-resources (data URIs, blobs) are still allowed. When a request is blocked, the command returns an error.\n\nNote: The WebSocket/EventSource blocking is best-effort -- it works by overriding the browser constructors via an init script. If the eval action category is allowed, page scripts could theoretically restore the original constructors. For maximum protection, deny the eval category via --action-policy when using --allowed-domains.\n\nConfig file:\n\n{\n  \"allowedDomains\": [\"example.com\", \"*.example.com\", \"github.com\"]\n}\n\nCDN and third-party resources: The domain filter blocks all sub-resource requests (scripts, stylesheets, images, fonts, fetch/XHR) to non-allowed domains. Most websites load assets from CDN domains. Include these in your allowlist or pages will break. For example:\n\n--allowed-domains \"myapp.com,*.myapp.com,cdn.jsdelivr.net,fonts.googleapis.com,fonts.gstatic.com\"\nACTION POLICY\n\nGate actions using a static policy file. The policy is enforced by the daemon -- denied actions fail immediately.\n\nagent-browser --action-policy ./policy.json open https://example.com\n# or\nexport AGENT_BROWSER_ACTION_POLICY=./policy.json\n\nExample policy (permissive with specific denials):\n\n{\n  \"default\": \"allow\",\n  \"deny\": [\"eval\", \"download\", \"upload\"]\n}\n\nExample policy (restrictive):\n\n{\n  \"default\": \"deny\",\n  \"allow\": [\"navigate\", \"snapshot\", \"click\", \"scroll\", \"wait\", \"get\"]\n}\nCATEGORY\tACTIONS\nnavigate\topen, back, forward, reload, tab new\nclick\tclick, dblclick, tap\nfill\tfill, type, keyboard type/inserttext, select, check, uncheck\neval\teval, evalhandle, addscript, addinitscript, addstyle, expose, setcontent\ndownload\tdownload, waitfordownload\nupload\tupload\nsnapshot\tsnapshot, screenshot, pdf, diff\nscroll\tscroll, scrollintoview\nwait\twait, waitforurl, waitforloadstate, waitforfunction\nget\tget text/html/url/title, count, isvisible, getbyrole, getbytext, getbylabel, etc.\ninteract\thover, focus, drag, press, keydown, keyup, mousemove, dispatch\nnetwork\tnetwork route/unroute, requests\nstate\tstate save/load, cookies set, storage set\n\nAuth vault operations (auth save, auth login, auth list, auth show, auth delete) and other internal/meta operations bypass action policy enforcement since they are trusted local operations. Domain allowlist restrictions still apply to auth login navigations.\n\nACTION CONFIRMATION\n\nFor actions that require explicit approval, use --confirm-actions to specify categories that require confirmation:\n\n# Orchestrator mode: returns confirmation_required response\nagent-browser --confirm-actions eval,download eval \"document.title\"\n\n# Then approve or deny:\nagent-browser confirm c_8f3a1234\nagent-browser deny c_8f3a1234\n\nFor interactive (human-in-the-loop) confirmation:\n\nagent-browser --confirm-actions eval,download --confirm-interactive eval \"document.title\"\n# Prompts: Allow? [y/N]\n\nPending confirmations auto-deny after 60 seconds.\n\nNon-TTY behavior: When --confirm-interactive is set but stdin is not a TTY (e.g., piped input or running inside an automated pipeline), actions are automatically denied. This prevents accidental approval in non-interactive contexts.\n\nOUTPUT LENGTH LIMITS\n\nPrevent context flooding by truncating large page outputs:\n\nagent-browser --max-output 50000 get text body\n# or\nexport AGENT_BROWSER_MAX_OUTPUT=50000\n\nAffected output types: snapshot, get text, get html, eval, console.\n\nENVIRONMENT VARIABLES\nVARIABLE\tDESCRIPTION\nAGENT_BROWSER_CONTENT_BOUNDARIES\tWrap page output in boundary markers\nAGENT_BROWSER_MAX_OUTPUT\tMax characters for page output\nAGENT_BROWSER_ALLOWED_DOMAINS\tComma-separated allowed domain patterns\nAGENT_BROWSER_ACTION_POLICY\tPath to action policy JSON file\nAGENT_BROWSER_CONFIRM_ACTIONS\tComma-separated action categories requiring confirmation\nAGENT_BROWSER_CONFIRM_INTERACTIVE\tEnable interactive confirmation prompts\nAGENT_BROWSER_ENCRYPTION_KEY\t64-char hex key for AES-256-GCM encryption (auth vault + sessions)\nRECOMMENDED CONFIGURATION\n\nFor production AI agent deployments:\n\n{\n  \"contentBoundaries\": true,\n  \"maxOutput\": 50000,\n  \"allowedDomains\": [\"your-app.com\", \"*.your-app.com\"],\n  \"actionPolicy\": \"./policy.json\"\n}\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  },
  {
    "id": 259006935,
    "timestamp": "2026-02-26T22:35:47.621Z",
    "title": "Changelog | agent-browser",
    "url": "https://agent-browser.dev/changelog",
    "text": "agent-browser\n14k\nnpm\nIntroduction\nInstallation\nQuick Start\nREFERENCE\nCommands\nConfiguration\nSelectors\nSnapshots\nFEATURES\nSessions\nDiffing\nCDP Mode\nStreaming\nProfiler\niOS Simulator\nSecurity\nChangelog\nChangelog\nV0.15.0\n\nFebruary 2026\n\nNew Features\nAuthentication vault -- Store credentials locally (always AES-256-GCM encrypted) and reference them by name. The LLM never sees passwords. Commands: auth save, auth login, auth list, auth show, auth delete. Passwords can be piped via stdin (--password-stdin) to avoid shell history exposure.\nContent boundary markers -- --content-boundaries wraps page-sourced output in structural delimiters with a per-process CSPRNG nonce, so LLMs can distinguish trusted tool output from untrusted page content. In --json mode, a _boundary object is injected with nonce and origin fields.\nDomain allowlist -- --allowed-domains restricts navigation, sub-resource requests, WebSocket connections, and EventSource streams to trusted domains. Supports exact match and wildcard prefix patterns (e.g., *.example.com).\nAction policy -- --action-policy gates actions using a static JSON policy file with allow/deny lists across 13 action categories. Auth vault operations bypass policy enforcement.\nAction confirmation -- --confirm-actions requires explicit approval for sensitive action categories. New confirm and deny commands for orchestrator use. --confirm-interactive enables human-in-the-loop terminal prompts (auto-denies if stdin is not a TTY). Pending confirmations auto-deny after 60 seconds.\nOutput length limits -- --max-output truncates large page outputs to prevent LLM context flooding.\n--download-path option -- Set a default download directory via flag, AGENT_BROWSER_DOWNLOAD_PATH env var, or downloadPath config key. Without it, downloads go to a temporary directory deleted when the browser closes.\n--selector flag for scroll -- Scroll within a specific container element instead of the page: agent-browser scroll down 500 --selector \"div.scroll-container\"\n# Auth vault\necho \"pass\" | agent-browser auth save github --url https://github.com/login --username user --password-stdin\nagent-browser auth login github\n\n# Security flags\nagent-browser --content-boundaries --allowed-domains \"example.com,*.example.com\" --max-output 50000 open https://example.com\n\n# Download path\nagent-browser --download-path ./downloads open https://example.com\n\n# Scroll within container\nagent-browser scroll down 500 --selector \"div.content\"\nEnvironment Variables\n\nSix new environment variables for security configuration: AGENT_BROWSER_CONTENT_BOUNDARIES, AGENT_BROWSER_MAX_OUTPUT, AGENT_BROWSER_ALLOWED_DOMAINS, AGENT_BROWSER_ACTION_POLICY, AGENT_BROWSER_CONFIRM_ACTIONS, AGENT_BROWSER_CONFIRM_INTERACTIVE.\n\nV0.14.0\n\nFebruary 2026\n\nNew Features\nkeyboard command -- Type with real keystrokes, insert text, and press shortcuts at the currently focused element without needing a selector (keyboard type, keyboard inserttext).\n--color-scheme flag -- Persistent dark/light mode preference across browser sessions via flag or AGENT_BROWSER_COLOR_SCHEME env var.\nagent-browser keyboard type \"Hello world\"\nagent-browser keyboard inserttext \"pasted text\"\nagent-browser --color-scheme dark open https://example.com\nBug Fixes\nFixed IPC EAGAIN errors (os error 35/11) with backpressure-aware socket writes, command serialization, and lowered default Playwright timeout to 25s (configurable via AGENT_BROWSER_DEFAULT_TIMEOUT).\nFixed remote debugging (CDP) reconnection.\nFixed state load failing when no browser is running.\nFixed --annotate flag warning appearing when not explicitly passed via CLI.\nV0.13.0\n\nFebruary 2026\n\nNew Features\nDiff commands -- Compare snapshots, screenshots, and URLs between page states. Run visual pixel diffs against baseline images, compare accessibility tree snapshots with customizable depth and selectors, and diff two URLs side-by-side with optional screenshot comparison.\nagent-browser diff snapshot\nagent-browser diff screenshot --baseline before.png\nagent-browser diff url https://staging.example.com https://prod.example.com\nV0.12.0\n\nFebruary 2026\n\nNew Features\nAnnotated screenshots -- --annotate flag overlays numbered labels on interactive elements and prints a legend mapping each label to its element ref. Enables multimodal AI models to reason about visual layout while using the same @eN refs for subsequent interactions. Also settable via AGENT_BROWSER_ANNOTATE env var.\nagent-browser screenshot --annotate\nV0.11.1\n\nFebruary 2026\n\nDocumentation\nAdded documentation for command chaining with && across README, CLI help output, docs, and skill files.\nV0.11.0\n\nFebruary 2026\n\nNew Features\nConfiguration file support -- Automatic loading from user (~/.agent-browser/config.json) and project (./agent-browser.json) directories with priority-based merging.\nProfiler commands -- Chrome DevTools profiling with profiler start and profiler stop.\nBrowser extension loading -- --extension flag to load browser extensions.\nStorage state management -- state save and state load commands for auth state persistence.\niOS device emulation -- --device flag for device emulation.\nEnhanced click -- --new-tab option for click commands.\nEnhanced find -- Additional actions and filtering options.\nCDP WebSocket URLs -- --cdp now accepts WebSocket URLs in addition to ports.\nV0.10.0\n\nFebruary 2026\n\nNew Features\nSession persistence - Automatic save/restore of cookies and localStorage across browser restarts using --session-name flag\nEncrypted state - Optional AES-256-GCM encryption for saved session state data\nState management commands - New commands for listing, showing, renaming, clearing, and cleaning up session state files\nNew tab on click - Added --new-tab option for click commands to open links in new tabs\n# Persist session state\nagent-browser --session-name myapp open https://example.com\n\n# Manage saved states\nagent-browser state list\nagent-browser state show myapp\nagent-browser state clear myapp\nV0.9.4\n\nFebruary 2026\n\nBug Fixes\nFixed all Clippy lint warnings in the Rust CLI\nV0.9.3\n\nFebruary 2026\n\nImprovements\nAdded support for custom executable path in CLI browser launch options\nDocumentation site UI improvements including a new chat component with sheet-based interface\nV0.9.2\n\nFebruary 2026\n\nImprovements\nMigrated documentation site to MDX for improved content authoring\nAdded AI-powered docs chat feature\nUpdated README with Homebrew installation instructions for macOS users\nV0.9.1\n\nFebruary 2026\n\nNew Features\n--allow-file-access flag - Enable opening and interacting with local file:// URLs (PDFs, HTML files) by passing Chromium flags that allow JavaScript access to local files\n-C/--cursor flag for snapshots - Include cursor-interactive elements like divs with onclick handlers or cursor:pointer styles\nagent-browser --allow-file-access open file:///path/to/document.pdf\nagent-browser snapshot -C\nV0.9.0\n\nFebruary 2026\n\nNew Features\niOS Simulator support - Mobile Safari testing via Appium with real device and simulator support\n# List available iOS simulators\nagent-browser device list\n\n# Launch on iOS device\nagent-browser -p ios --device \"iPhone 16 Pro\" open https://example.com\n\n# Touch interactions\nagent-browser tap @e1\nagent-browser swipe up\nV0.8.10\n\nJanuary 2026\n\nImprovements\nAdded --stdin flag for eval command to read JavaScript from stdin, enabling heredoc usage for multiline scripts\nFixed binary permission issues on macOS/Linux when postinstall scripts don't run\nV0.8.9\n\nJanuary 2026\n\nImprovements\nAdded --stdin flag for eval command to read JavaScript from stdin\nV0.8.8\n\nJanuary 2026\n\nImprovements\nAdded base64 encoding support for the eval command with -b/--base64 flag to avoid shell escaping issues\nUpdated documentation with AI agent setup instructions\nV0.8.7\n\nJanuary 2026\n\nBug Fixes\nFixed browser launch options not being passed correctly when using persistent profiles\nAdded pre-flight checks for socket path length limits and directory write permissions\nImproved error handling to properly exit with failure status when browser launch fails\nV0.8.6\n\nJanuary 2026\n\nBug Fixes\nImproved daemon connection reliability with automatic retry logic for transient errors\nCLI now cleans up stale socket and PID files before starting a new daemon\nV0.8.5\n\nJanuary 2026\n\nBug Fixes\nFixed version synchronization to automatically update Cargo.lock alongside Cargo.toml during releases\nMade the CLI binary executable in the npm package\nV0.8.4\n\nJanuary 2026\n\nBug Fixes\nFixed \"Daemon not found\" error when running through AI agents by resolving symlinks in the executable path\nV0.8.3\n\nJanuary 2026\n\nImprovements\nReplaced shell-based CLI wrappers with a cross-platform Node.js wrapper to enable npx support on Windows\nAdded postinstall logic to patch npm bin entry on global installs for zero-overhead native binary invocation\nAdded CI tests to verify global installation across all platforms\nV0.8.2\n\nJanuary 2026\n\nBug Fixes\nFixed the Windows CMD wrapper to use the native binary directly instead of routing through Node.js\nAdded retry logic to CI install command for transient browser installation failures\nV0.8.1\n\nJanuary 2026\n\nImprovements\nImproved release workflow to validate binary file sizes and ensure binaries are executable after npm install\nUpdated documentation site with a new mobile navigation system\nV0.8.0\n\nJanuary 2026\n\nNew Features\nKernel cloud browser provider - Connect to Kernel (kernel.sh) for remote browser infrastructure with stealth mode and persistent profiles\n# Via -p flag\nagent-browser -p kernel open https://example.com\n\n# Via environment variable\nexport AGENT_BROWSER_PROVIDER=kernel\nexport KERNEL_API_KEY=your-api-key\nagent-browser open https://example.com\n\n# With persistent profile\nexport KERNEL_PROFILE_NAME=my-profile\nagent-browser open https://example.com\nIgnore HTTPS certificate errors - New flag for working with self-signed certificates and development environments\nagent-browser --ignore-https-errors open https://localhost:3000\nEnhanced cookie management - Extended cookies set command with additional flags for setting cookies before page load\nagent-browser cookies set session_id \"abc123\" --url https://app.example.com --httpOnly --secure\nagent-browser cookies set token \"xyz\" --domain .example.com --path /api --expires 1735689600\nBug Fixes\nFixed tab list command not recognizing new pages opened via clicks or target=\"_blank\" links\nFixed check command hanging indefinitely\nFixed set device not applying deviceScaleFactor - HiDPI screenshots now work correctly\nFixed state load and profile persistence not working in v0.7.6\nScreenshots now save to temp directory when no path is provided\nSecurity\nDaemon and stream server now reject cross-origin connections\nV0.7.1\n\nJanuary 2026\n\nBug Fixes\nFix native binary distribution - Native binaries for all platforms (Linux x64/arm64, macOS x64/arm64, Windows x64) are now included in the npm package. Previously, the release workflow published to npm before building binaries, causing \"No binary found\" errors on installation.\nV0.7.0\n\nJanuary 2026\n\nNew Features\nCloud browser providers - Connect to Browserbase or Browser Use for remote browser infrastructure\n# Via -p flag (recommended)\nagent-browser -p browserbase open https://example.com\nagent-browser -p browseruse open https://example.com\n\n# Via environment variable\nexport AGENT_BROWSER_PROVIDER=browserbase\nagent-browser open https://example.com\nPersistent browser profiles - Store cookies, localStorage, and login sessions across browser restarts\nagent-browser --profile ~/.myapp-profile open myapp.com\n# Login persists across restarts\nRemote CDP WebSocket URLs - Connect to remote browser services via WebSocket\nagent-browser --cdp \"wss://browser-service.com/cdp?token=...\" snapshot\ndownload command - Trigger downloads and wait for completion\nagent-browser download @e1 ./file.pdf\nagent-browser wait --download ./output.zip --timeout 30000\nBrowser launch configuration - Fine-grained control over browser startup\nagent-browser --args \"--disable-gpu,--no-sandbox\" open example.com\nagent-browser --user-agent \"Custom UA\" open example.com\nagent-browser --proxy-bypass \"localhost,*.internal\" open example.com\nEnhanced skills - Hierarchical structure with references and templates for Claude Code\nBug Fixes\nScreenshot command now supports refs and has improved error messages\nWebSocket URLs work in connect command\nFixed socket file location (uses ~/.agent-browser instead of TMPDIR)\nWindows binary path fix (.exe extension)\nState load and path-based actions now show correct output messages\nDocumentation\nAdded Claude Code marketplace plugin installation instructions\nUpdated skill documentation with references and templates\nImproved error documentation\nV0.6.0\n\nJanuary 2026\n\nNew Features\nVideo recording - Record browser sessions to WebM using Playwright's native recording\nagent-browser record start ./demo.webm\nagent-browser click @e1\nagent-browser record stop\nconnect command - Connect to a browser via CDP and persist the connection for subsequent commands\nagent-browser connect 9222\nagent-browser snapshot  # No --cdp needed after connect\n--proxy flag - Configure browser proxy with optional authentication\nagent-browser --proxy http://user:pass@proxy.com:8080 open example.com\nget styles command - Extract computed styles from elements\nagent-browser get styles \"button\"\nClaude marketplace plugin - Added .claude-plugin/marketplace.json for Claude Code integration\nEnhanced network output - network requests now shows method, URL, and resource type\n--version flag - Display CLI version\nBug Fixes\nFix Windows daemon startup and port calculation\nSupport libasound2t64 on newer Ubuntu versions (24.04+)\nPrevent CDP timeout on empty URL tabs\nOutput screenshot as base64 when no path provided\nResolve refs in get value command\nSupport URL parameter in tab new command\nAllow about:, data:, and file: URL schemes\nDetect stale unix socket by attempting connection\nRespect AGENT_BROWSER_HEADED environment variable\nHandle SIGPIPE to prevent panic when piping to head/tail\nFix null path validation in screenshot command\nProtocol Alignment\n\nThese changes align the CLI with the daemon protocol for consistency:\n\nselect command now uses values field (supports multiple selections)\nframe main uses mainframe action\nmouse wheel uses wheel action\nset media uses emulatemedia action\nConsole output uses messages field\nDocumentation\nExpanded SKILL.md with comprehensive command reference\nUpdated README with new commands and options\nUpdated CDP mode documentation with connect workflow\nAsk AI\n⌘\nK\nagent-browser Docs\nWhat is agent-browser?\nHow do I install it?\nWhat commands are available?\nHow do snapshots work?\nHow do I use CDP mode?",
    "contentType": "html",
    "extractionMethod": "dom"
  }
]
